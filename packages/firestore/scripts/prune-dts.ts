/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as yargs from 'yargs';
import * as ts from 'typescript';
import * as fs from 'fs';

/**
 * Prunes a DTS file based on three main rules:
 * - Top level types are only included if they are also exported.
 * - Underscore-prefixed members of class and interface types are stripped.
 * - Constructors are made private or protected if marked with
 *   `@hideconstructor`/`@hideconstructor protected`.
 *
 * This function is meant to operate on DTS files generated by API extractor
 * and extracts out the API that is relevant for third-party SDK consumers.
 *
 * @param inputLocation The file path to the .d.ts produced by API explorer.
 * @param outputLocation The output location for the pruned .d.ts file.
 */
function main(inputLocation: string, outputLocation: string): void {
  const compilerOptions = {};
  const host = ts.createCompilerHost(compilerOptions);
  const program = ts.createProgram([inputLocation], compilerOptions, host);
  const typeChecker = program.getTypeChecker();
  const printer: ts.Printer = ts.createPrinter();
  const sourceFile = program.getSourceFile(inputLocation)!;
  const result: ts.TransformationResult<ts.SourceFile> = ts.transform<
    ts.SourceFile
  >(sourceFile, [dropPrivateApiTransformer.bind(null, typeChecker)]);
  const transformedSourceFile: ts.SourceFile = result.transformed[0];
  const content = printer.printFile(transformedSourceFile);
  console.log(content);
  fs.writeFileSync(outputLocation, content);
}

/** Determines whether the provided identifier should be hidden. */
function hasPrivatePrefix(name: ts.Identifier): boolean {
  // Identifiers that are prefixed with an underscore are not not included in
  // the public API.
  return name.escapedText.toString().startsWith('_');
}

/** Returns whether the modifier array includes `exported`. */
function isExported(modifiers?: ts.ModifiersArray): boolean {
  return !!modifiers?.find(m => m.kind === ts.SyntaxKind.ExportKeyword);
}

/**
 * Replaces an existing constructor implementation if the constructor is marked
 * with the JSDod tag `@hideconstructor`. The replaced constructor can either
 * have `private` visibility` or `proctected`. To generate a protected
 * constructor, specify `@hideconstructor proctected`.
 *
 * Returns either the modified constructor or the existing constructor if no
 * modification was needed.
 */
function maybeHideConstructor(
  node: ts.ConstructorDeclaration
): ts.ConstructorDeclaration {
  const hideConstructorTag = ts
    .getJSDocTags(node)
    ?.find(t => t.tagName.escapedText === 'hideconstructor');

  if (hideConstructorTag) {
    const modifier = ts.createModifier(
      hideConstructorTag.comment === 'protected'
        ? ts.SyntaxKind.ProtectedKeyword
        : ts.SyntaxKind.PrivateKeyword
    );
    return ts.createConstructor(
      node.decorators,
      [modifier],
      /*parameters=*/ [],
      /* body= */ undefined
    );
  } else {
    return node;
  }
}

function visit<T extends ts.Node>(
  typeChecker: ts.TypeChecker,
  originalLocation: ts.Node,
  d: T
): T {
  return ts.transform(d, [
    updateInheritedTypeTransformer.bind(null, typeChecker, originalLocation)
  ]).transformed[0] as T;
}

/**
 * Examines `extends` and `implements` clauses and removes or replaces them if
 * they refer to a non-exported type. When an export is removed, all members
 * from the removed class are merged into the provided class or interface
 * declaration.
 *
 * @example
 * Input:
 * class Foo {
 *   foo: string;
 * }
 * export class Bar extends Foo {}
 *
 * Output:
 * export class Bar {
 *   foo: string;
 * }
 */
function prunePrivateImports<
  T extends ts.InterfaceDeclaration | ts.ClassDeclaration
>(typeChecker: ts.TypeChecker, sourceFile: ts.SourceFile, node: T): T {
  const currentType = typeChecker.getTypeAtLocation(node);
  const currentName = currentType?.symbol?.name;
  const currentMembers = currentType?.symbol?.members;

  // The list of heritage clauses after all private symbols are removed.
  const prunedHeritageClauses: ts.HeritageClause[] = [];
  // Additional members that are copied from the private symbols into the public
  // symbols
  const additionalMembers: ts.NamedDeclaration[] = [];

  for (const heritageClause of node.heritageClauses || []) {
    const exportedTypes: ts.ExpressionWithTypeArguments[] = [];
    for (const type of heritageClause.types) {
      if (isExported(type.modifiers)) {
        exportedTypes.push(type);
      } else {
        const publicSymbol = extractPublicSymbol(
          typeChecker,
          sourceFile,
          type.expression
        );
        if (publicSymbol && publicSymbol.name !== currentName) {
          // If there is a public type that we can refer to, update the import
          // statement to refer to the public type.
          exportedTypes.push(
            ts.updateExpressionWithTypeArguments(
              type,
              type.typeArguments,
              ts.createIdentifier(publicSymbol.name)
            )
          );
        } else {
          // Iterate all members of the private type and add them to the
          // public type if they are not already part of the public type.
          const privateType = typeChecker.getTypeAtLocation(type);
          if (privateType?.symbol?.members) {
            privateType.symbol.members!.forEach((definition, memberName) => {
              if (!currentMembers || !currentMembers.has(memberName)) {
                additionalMembers.push(
                  ...definition.declarations.map(d =>
                    visit(typeChecker, type, d)
                  )
                );
              }
            });
          }
        }
      }
    }

    // for (const property of privateType.getProperties()) {
    //   for (const declaration of property.declarations) {
    //     if (ts.isPropertyDeclaration(declaration)) {
    //
    //       const localType = typeChecker.typeToTypeNode(typeChecker.getTypeOfSymbolAtLocation(property, type), node, undefined);
    //
    //       const updatedElement = ts.updateProperty(declaration, declaration.decorators, declaration.modifiers, declaration.name, declaration.questionToken || declaration.exclamationToken, localType, declaration.initializer);
    //       additionalMembers.push(updatedElement);
    //     }
    //   }
    // }
    if (exportedTypes.length > 0) {
      prunedHeritageClauses.push(
        ts.updateHeritageClause(heritageClause, exportedTypes)
      );
    }
  }

  if (ts.isClassDeclaration(node)) {
    return ts.updateClassDeclaration(
      node,
      node.decorators,
      node.modifiers,
      node.name,
      node.typeParameters,
      prunedHeritageClauses,
      [...node.members, ...(additionalMembers as ts.ClassElement[])]
    ) as T;
  } else if (ts.isInterfaceDeclaration(node)) {
    return ts.updateInterfaceDeclaration(
      node,
      node.decorators,
      node.modifiers,
      node.name,
      node.typeParameters,
      prunedHeritageClauses,
      [...node.members, ...(additionalMembers as ts.TypeElement[])]
    ) as T;
  } else {
    throw new Error('Only classes or interfaces are supported');
  }
}

/**
 * Replaces input types of public APIs that consume non-exported types, which
 * allows us to exclude private types from the pruned definitions. Returns the
 * the name of the exported API or undefined if no type is found.
 *
 * @example
 * Input:
 * class PrivateFoo {}
 * export class PublicFoo extends PrivateFoo {}
 * export function doFoo(foo: PrivateFoo);
 *
 * Output:
 * export class PublicFoo {}
 * export function doFoo(foo: PublicFoo);
 */
function extractPublicSymbol(
  typeChecker: ts.TypeChecker,
  sourceFile: ts.SourceFile,
  typeName: ts.Node
): ts.Symbol | undefined {
  if (!ts.isIdentifier(typeName)) {
    return undefined;
  }

  const localSymbolName = typeName.escapedText;

  const allPublicSymbols = typeChecker.getExportsOfModule(
    typeChecker.getSymbolAtLocation(sourceFile)!
  );
  const publicSymbolsForLocalType: ts.Symbol[] = [];

  // Examine all exported types and check if they extend or implement the
  // provided local type. If so, we can use the exported type in lieu of the
  // private type.
  for (const symbol of allPublicSymbols) {
    // Short circuit if the local types is already part of the public types.
    if (symbol.name === localSymbolName) {
      return symbol;
    }

    for (const declaration of symbol.declarations) {
      if (
        ts.isClassDeclaration(declaration) ||
        ts.isInterfaceDeclaration(declaration)
      ) {
        for (const heritageClause of declaration.heritageClauses || []) {
          for (const type of heritageClause.types || []) {
            if (ts.isIdentifier(type.expression)) {
              const subclassName = type.expression.escapedText;
              if (subclassName === localSymbolName) {
                publicSymbolsForLocalType.push(symbol);
              }
            }
          }
        }
      }
    }
  }

  return publicSymbolsForLocalType[0];
}

const updateInheritedTypeTransformer = (
  typeChecker: ts.TypeChecker,
  originalLocation: ts.Node,
  context: ts.TransformationContext
) => {
  return (sourceFile: ts.Node) => {
    function visit(node: ts.Node): ts.Node {
      if (ts.isTypeReferenceNode(node)) {
        const symbol = typeChecker.getSymbolAtLocation(node.typeName);
        const replacement = typeChecker.getTypeOfSymbolAtLocation(
          symbol!,
          originalLocation
        );
        if (replacement) {
          return ts.updateTypeReferenceNode(
            node,
            ts.createIdentifier('string'),
            node.typeArguments
          );
        } else {
          return node;
        }
      }

      return node;
    }

    function visitNodeAndChildren<T extends ts.Node>(node: T): T {
      return ts.visitEachChild(
        visit(node),
        childNode => visitNodeAndChildren(childNode),
        context
      ) as T;
    }
    return visitNodeAndChildren(sourceFile);
  };
};

const dropPrivateApiTransformer = (
  typeChecker: ts.TypeChecker,
  context: ts.TransformationContext
) => {
  return (sourceFile: ts.SourceFile) => {
    function visit(node: ts.Node): ts.Node {
      if (
        ts.isInterfaceDeclaration(node) ||
        ts.isClassDeclaration(node) ||
        ts.isFunctionDeclaration(node) ||
        ts.isVariableStatement(node) ||
        ts.isTypeAliasDeclaration(node) ||
        ts.isModuleDeclaration(node) ||
        ts.isEnumDeclaration(node)
      ) {
        // Remove any types that are not exported.
        if (!isExported(node.modifiers)) {
          return ts.createToken(ts.SyntaxKind.WhitespaceTrivia);
        }
      }

      if (ts.isConstructorDeclaration(node)) {
        // Replace internal constructors with private constructors.
        return maybeHideConstructor(node);
      } else if (
        ts.isClassDeclaration(node) ||
        ts.isInterfaceDeclaration(node)
      ) {
        // Remove any imports that reference internal APIs, while retaining
        // their public members.
        return prunePrivateImports(typeChecker, sourceFile, node);
      } else if (
        ts.isPropertyDeclaration(node) ||
        ts.isMethodDeclaration(node) ||
        ts.isGetAccessor(node)
      ) {
        // Remove any class and interface members that are prefixed with
        // underscores.
        if (hasPrivatePrefix(node.name as ts.Identifier)) {
          return ts.createToken(ts.SyntaxKind.WhitespaceTrivia);
        }
      } else if (ts.isTypeReferenceNode(node)) {
        // For public types that refer internal types, find a public type that
        // we can refer to instead.
        const publicName = extractPublicSymbol(
          typeChecker,
          sourceFile,
          node.typeName
        );
        return publicName
          ? ts.updateTypeReferenceNode(
              node,
              ts.createIdentifier(publicName.name),
              node.typeArguments
            )
          : node;
      }

      return node;
    }

    function visitNodeAndChildren<T extends ts.Node>(node: T): T {
      return ts.visitEachChild(
        visit(node),
        childNode => visitNodeAndChildren(childNode),
        context
      ) as T;
    }
    return visitNodeAndChildren(sourceFile);
  };
};

const argv = yargs.options({
  input: {
    type: 'string',
    demandOption: true,
    desc: 'The location of the index.ts file'
  },
  output: {
    type: 'string',
    demandOption: true,
    desc: 'The location for the index.d.ts file'
  }
}).argv;

main(argv.input, argv.output);
