## API Report File for "@firebase/auth-exp"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { CompleteFn } from '@firebase/util';
import { ErrorFactory } from '@firebase/util';
import { ErrorFn } from '@firebase/util';
import { FirebaseApp } from '@firebase/app-exp';
import { FirebaseError } from '@firebase/util';
import { NextFn } from '@firebase/util';
import { Observer } from '@firebase/util';
import { Unsubscribe } from '@firebase/util';

// @public
export interface ActionCodeInfo {
    data: {
        email?: string | null;
        multiFactorInfo?: MultiFactorInfo | null;
        previousEmail?: string | null;
    };
    operation: typeof ActionCodeOperation[keyof typeof ActionCodeOperation];
}

// @public
export const ActionCodeOperation: {
    readonly EMAIL_SIGNIN: "EMAIL_SIGNIN";
    readonly PASSWORD_RESET: "PASSWORD_RESET";
    readonly RECOVER_EMAIL: "RECOVER_EMAIL";
    readonly REVERT_SECOND_FACTOR_ADDITION: "REVERT_SECOND_FACTOR_ADDITION";
    readonly VERIFY_AND_CHANGE_EMAIL: "VERIFY_AND_CHANGE_EMAIL";
    readonly VERIFY_EMAIL: "VERIFY_EMAIL";
};

// @public
export interface ActionCodeSettings {
    android?: {
        installApp?: boolean;
        minimumVersion?: string;
        packageName: string;
    };
    dynamicLinkDomain?: string;
    handleCodeInApp?: boolean;
    iOS?: {
        bundleId: string;
    };
    url: string;
}

// @public
export class ActionCodeURL {
    // @internal
    constructor(actionLink: string);
    readonly apiKey: string;
    readonly code: string;
    readonly continueUrl: string | null;
    readonly languageCode: string | null;
    readonly operation: string;
    static parseLink(link: string): ActionCodeURL | null;
    readonly tenantId: string | null;
}

// @public
export interface AdditionalUserInfo {
    readonly isNewUser: boolean;
    readonly profile: Record<string, unknown> | null;
    readonly providerId: string | null;
    readonly username?: string | null;
}

// @public
export interface ApplicationVerifier {
    readonly type: string;
    verify(): Promise<string>;
}

// @public
export function applyActionCode(auth: Auth, oobCode: string): Promise<void>;

// @public
export interface Auth {
    readonly config: Config;
    readonly currentUser: User | null;
    // Warning: (ae-forgotten-export) The symbol "EmulatorConfig" needs to be exported by the entry point index.d.ts
    readonly emulatorConfig: EmulatorConfig | null;
    languageCode: string | null;
    readonly name: string;
    onAuthStateChanged(nextOrObserver: NextOrObserver<User | null>, error?: ErrorFn, completed?: CompleteFn): Unsubscribe;
    onIdTokenChanged(nextOrObserver: NextOrObserver<User | null>, error?: ErrorFn, completed?: CompleteFn): Unsubscribe;
    setPersistence(persistence: Persistence): Promise<void>;
    readonly settings: AuthSettings;
    signOut(): Promise<void>;
    tenantId: string | null;
    updateCurrentUser(user: User | null): Promise<void>;
    useDeviceLanguage(): void;
}

// @public
export class AuthCredential {
    // @internal
    protected constructor(
    providerId: string,
    signInMethod: string);
    // Warning: (ae-forgotten-export) The symbol "AuthInternal" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "PhoneOrOauthTokenResponse" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    _getIdTokenResponse(_auth: AuthInternal): Promise<PhoneOrOauthTokenResponse>;
    // @internal (undocumented)
    _getReauthenticationResolver(_auth: AuthInternal): Promise<IdTokenResponse>;
    // Warning: (ae-forgotten-export) The symbol "IdTokenResponse" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    _linkToIdToken(_auth: AuthInternal, _idToken: string): Promise<IdTokenResponse>;
    readonly providerId: string;
    readonly signInMethod: string;
    toJSON(): object;
}

// @public
export interface AuthError extends FirebaseError {
    readonly appName: string;
    readonly email?: string;
    readonly phoneNumber?: string;
    readonly tenantid?: string;
}

// @public
export interface AuthErrorMap {
}

// @public
export interface AuthProvider {
    readonly providerId: string;
}

// @public
export interface AuthSettings {
    appVerificationDisabledForTesting: boolean;
}

// @public
export const browserLocalPersistence: Persistence;

// @public
export const browserPopupRedirectResolver: PopupRedirectResolver;

// @public
export const browserSessionPersistence: Persistence;

// @public
export function checkActionCode(auth: Auth, oobCode: string): Promise<ActionCodeInfo>;

export { CompleteFn }

// @public
export interface Config {
    apiHost: string;
    apiKey: string;
    apiScheme: string;
    authDomain?: string;
    sdkClientVersion: string;
    tokenApiHost: string;
}

// @public
export interface ConfirmationResult {
    confirm(verificationCode: string): Promise<UserCredential>;
    readonly verificationId: string;
}

// @public
export function confirmPasswordReset(auth: Auth, oobCode: string, newPassword: string): Promise<void>;

// @public
export function connectAuthEmulator(auth: Auth, url: string, options?: {
    disableWarnings: boolean;
}): void;

// @public
export function createUserWithEmailAndPassword(auth: Auth, email: string, password: string): Promise<UserCredential>;

// @public
export type CustomParameters = Record<string, string>;

// @public
export const debugErrorMap: AuthErrorMap;

// @public
export function deleteUser(user: User): Promise<void>;

// @public
export interface Dependencies {
    errorMap?: AuthErrorMap;
    persistence?: Persistence | Persistence[];
    popupRedirectResolver?: PopupRedirectResolver;
}

// @public
export class EmailAuthCredential extends AuthCredential {
    // @internal (undocumented)
    readonly _email: string;
    // @internal (undocumented)
    static _fromEmailAndCode(email: string, oobCode: string, tenantId?: string | null): EmailAuthCredential;
    // @internal (undocumented)
    static _fromEmailAndPassword(email: string, password: string): EmailAuthCredential;
    static fromJSON(json: object | string): EmailAuthCredential | null;
    // @internal (undocumented)
    _getIdTokenResponse(auth: AuthInternal): Promise<IdTokenResponse>;
    // @internal (undocumented)
    _getReauthenticationResolver(auth: AuthInternal): Promise<IdTokenResponse>;
    // @internal (undocumented)
    _linkToIdToken(auth: AuthInternal, idToken: string): Promise<IdTokenResponse>;
    // @internal (undocumented)
    readonly _password: string;
    // @internal (undocumented)
    readonly _tenantId: string | null;
    toJSON(): object;
}

// @public
export class EmailAuthProvider implements AuthProvider {
    static credential(email: string, password: string): EmailAuthCredential;
    static credentialWithLink(email: string, emailLink: string): EmailAuthCredential;
    static readonly EMAIL_LINK_SIGN_IN_METHOD: 'emailLink';
    static readonly EMAIL_PASSWORD_SIGN_IN_METHOD: 'password';
    static readonly PROVIDER_ID: 'password';
    readonly providerId: "password";
}

export { ErrorFn }

// Warning: (ae-forgotten-export) The symbol "BaseOAuthProvider" needs to be exported by the entry point index.d.ts
//
// @public
export class FacebookAuthProvider extends BaseOAuthProvider {
    constructor();
    static credential(accessToken: string): OAuthCredential;
    static credentialFromError(error: FirebaseError): OAuthCredential | null;
    static credentialFromResult(userCredential: UserCredential): OAuthCredential | null;
    static readonly FACEBOOK_SIGN_IN_METHOD: 'facebook.com';
    static readonly PROVIDER_ID: 'facebook.com';
}

// @public
export const FactorId: {
    readonly PHONE: "phone";
};

// @public
export function fetchSignInMethodsForEmail(auth: Auth, email: string): Promise<string[]>;

// @public
export function getAdditionalUserInfo(userCredential: UserCredential): AdditionalUserInfo | null;

// @public
export function getAuth(app?: FirebaseApp): Auth;

// @public
export function getIdToken(user: User, forceRefresh?: boolean): Promise<string>;

// @public
export function getIdTokenResult(user: User, forceRefresh?: boolean): Promise<IdTokenResult>;

// @public
export function getMultiFactorResolver(auth: Auth, error: MultiFactorError): MultiFactorResolver;

// @public
export function getRedirectResult(auth: Auth, resolver?: PopupRedirectResolver): Promise<UserCredential | null>;

// @public
export class GithubAuthProvider extends BaseOAuthProvider {
    constructor();
    static credential(accessToken: string): OAuthCredential;
    static credentialFromError(error: FirebaseError): OAuthCredential | null;
    static credentialFromResult(userCredential: UserCredential): OAuthCredential | null;
    static readonly GITHUB_SIGN_IN_METHOD: 'github.com';
    static readonly PROVIDER_ID: 'github.com';
}

// @public
export class GoogleAuthProvider extends BaseOAuthProvider {
    constructor();
    static credential(idToken?: string | null, accessToken?: string | null): OAuthCredential;
    static credentialFromError(error: FirebaseError): OAuthCredential | null;
    static credentialFromResult(userCredential: UserCredential): OAuthCredential | null;
    static readonly GOOGLE_SIGN_IN_METHOD: 'google.com';
    static readonly PROVIDER_ID: 'google.com';
}

// @public
export interface IdTokenResult {
    authTime: string;
    claims: ParsedToken;
    expirationTime: string;
    issuedAtTime: string;
    signInProvider: string | null;
    signInSecondFactor: string | null;
    token: string;
}

// @public
export const indexedDBLocalPersistence: Persistence;

// @public
export function initializeAuth(app: FirebaseApp, deps?: Dependencies): Auth;

// @public
export const inMemoryPersistence: Persistence;

// @public
export function isSignInWithEmailLink(auth: Auth, emailLink: string): boolean;

// @public
export function linkWithCredential(user: User, credential: AuthCredential): Promise<UserCredential>;

// @public
export function linkWithPhoneNumber(user: User, phoneNumber: string, appVerifier: ApplicationVerifier): Promise<ConfirmationResult>;

// @public
export function linkWithPopup(user: User, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<UserCredential>;

// @public
export function linkWithRedirect(user: User, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<never>;

// @public
export function multiFactor(user: User): MultiFactorUser;

// @public
export interface MultiFactorAssertion {
    readonly factorId: typeof FactorId[keyof typeof FactorId];
}

// @public
export interface MultiFactorError extends AuthError {
    readonly operationType: typeof OperationType[keyof typeof OperationType];
}

// @public
export interface MultiFactorInfo {
    readonly displayName?: string | null;
    readonly enrollmentTime: string;
    readonly factorId: typeof FactorId[keyof typeof FactorId];
    readonly uid: string;
}

// @public
export interface MultiFactorResolver {
    readonly hints: MultiFactorInfo[];
    resolveSignIn(assertion: MultiFactorAssertion): Promise<UserCredential>;
    readonly session: MultiFactorSession;
}

// @public
export interface MultiFactorSession {
}

// @public
export interface MultiFactorUser {
    enroll(assertion: MultiFactorAssertion, displayName?: string | null): Promise<void>;
    readonly enrolledFactors: MultiFactorInfo[];
    getSession(): Promise<MultiFactorSession>;
    unenroll(option: MultiFactorInfo | string): Promise<void>;
}

// @public
export type NextOrObserver<T> = NextFn<T | null> | Observer<T | null>;

// @public
export class OAuthCredential extends AuthCredential {
    accessToken?: string;
    static fromJSON(json: string | object): OAuthCredential | null;
    // Warning: (ae-forgotten-export) The symbol "OAuthCredentialParams" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    static _fromParams(params: OAuthCredentialParams): OAuthCredential;
    // @internal (undocumented)
    _getIdTokenResponse(auth: AuthInternal): Promise<IdTokenResponse>;
    // @internal (undocumented)
    _getReauthenticationResolver(auth: AuthInternal): Promise<IdTokenResponse>;
    idToken?: string;
    // @internal (undocumented)
    _linkToIdToken(auth: AuthInternal, idToken: string): Promise<IdTokenResponse>;
    // @internal (undocumented)
    nonce?: string;
    secret?: string;
    toJSON(): object;
}

// @public
export interface OAuthCredentialOptions {
    accessToken?: string;
    idToken?: string;
    rawNonce?: string;
}

// @public
export class OAuthProvider extends BaseOAuthProvider {
    credential(params: OAuthCredentialOptions): OAuthCredential;
    static credentialFromError(error: FirebaseError): OAuthCredential | null;
    static credentialFromJSON(json: object | string): OAuthCredential;
    static credentialFromResult(userCredential: UserCredential): OAuthCredential | null;
    }

// @public
export function onAuthStateChanged(auth: Auth, nextOrObserver: NextOrObserver<User>, error?: ErrorFn, completed?: CompleteFn): Unsubscribe;

// @public
export function onIdTokenChanged(auth: Auth, nextOrObserver: NextOrObserver<User>, error?: ErrorFn, completed?: CompleteFn): Unsubscribe;

// @public
export const OperationType: {
    readonly LINK: "link";
    readonly REAUTHENTICATE: "reauthenticate";
    readonly SIGN_IN: "signIn";
};

// @public
export function parseActionCodeURL(link: string): ActionCodeURL | null;

// @public
export interface ParsedToken {
    [key: string]: string | object | undefined;
    'auth_time'?: string;
    'exp'?: string;
    'firebase'?: {
        'sign_in_provider'?: string;
        'sign_in_second_factor'?: string;
    };
    'iat'?: string;
    'sub'?: string;
}

// @public
export interface Persistence {
    readonly type: 'SESSION' | 'LOCAL' | 'NONE';
}

// @public
export class PhoneAuthCredential extends AuthCredential {
    static fromJSON(json: object | string): PhoneAuthCredential | null;
    // @internal (undocumented)
    static _fromTokenResponse(phoneNumber: string, temporaryProof: string): PhoneAuthCredential;
    // @internal (undocumented)
    static _fromVerification(verificationId: string, verificationCode: string): PhoneAuthCredential;
    // @internal (undocumented)
    _getIdTokenResponse(auth: AuthInternal): Promise<PhoneOrOauthTokenResponse>;
    // @internal (undocumented)
    _getReauthenticationResolver(auth: AuthInternal): Promise<IdTokenResponse>;
    // @internal (undocumented)
    _linkToIdToken(auth: AuthInternal, idToken: string): Promise<IdTokenResponse>;
    // Warning: (ae-forgotten-export) The symbol "SignInWithPhoneNumberRequest" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    _makeVerificationRequest(): SignInWithPhoneNumberRequest;
    toJSON(): object;
}

// @public
export class PhoneAuthProvider {
    constructor(auth: Auth);
    static credential(verificationId: string, verificationCode: string): PhoneAuthCredential;
    static credentialFromError(error: FirebaseError): AuthCredential | null;
    static credentialFromResult(userCredential: UserCredential): AuthCredential | null;
    static readonly PHONE_SIGN_IN_METHOD: 'phone';
    static readonly PROVIDER_ID: 'phone';
    readonly providerId: "phone";
    verifyPhoneNumber(phoneOptions: PhoneInfoOptions | string, applicationVerifier: ApplicationVerifier): Promise<string>;
}

// @public
export type PhoneInfoOptions = PhoneSingleFactorInfoOptions | PhoneMultiFactorEnrollInfoOptions | PhoneMultiFactorSignInInfoOptions;

// @public
export interface PhoneMultiFactorAssertion extends MultiFactorAssertion {
}

// @public
export interface PhoneMultiFactorEnrollInfoOptions {
    phoneNumber: string;
    session: MultiFactorSession;
}

// @public
export class PhoneMultiFactorGenerator {
    static assertion(credential: PhoneAuthCredential): PhoneMultiFactorAssertion;
}

// @public
export interface PhoneMultiFactorSignInInfoOptions {
    multiFactorHint?: MultiFactorInfo;
    multiFactorUid?: string;
    session: MultiFactorSession;
}

// @public
export interface PhoneSingleFactorInfoOptions {
    phoneNumber: string;
}

// @public
export interface PopupRedirectResolver {
}

// @public
export const prodErrorMap: AuthErrorMap;

// @public
export const ProviderId: {
    readonly FACEBOOK: "facebook.com";
    readonly GITHUB: "github.com";
    readonly GOOGLE: "google.com";
    readonly PASSWORD: "password";
    readonly PHONE: "phone";
    readonly TWITTER: "twitter.com";
};

// @public
export interface ReactNativeAsyncStorage {
    getItem(key: string): Promise<string | null>;
    removeItem(key: string): Promise<void>;
    setItem(key: string, value: string): Promise<void>;
}

// @public
export function reauthenticateWithCredential(user: User, credential: AuthCredential): Promise<UserCredential>;

// @public
export function reauthenticateWithPhoneNumber(user: User, phoneNumber: string, appVerifier: ApplicationVerifier): Promise<ConfirmationResult>;

// @public
export function reauthenticateWithPopup(user: User, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<UserCredential>;

// @public
export function reauthenticateWithRedirect(user: User, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<never>;

// Warning: (ae-forgotten-export) The symbol "ApplicationVerifierInternal" needs to be exported by the entry point index.d.ts
//
// @public
export class RecaptchaVerifier implements ApplicationVerifierInternal {
    // Warning: (ae-forgotten-export) The symbol "Parameters" needs to be exported by the entry point index.d.ts
    constructor(containerOrId: HTMLElement | string, parameters: Parameters_2, authExtern: Auth);
    clear(): void;
    // Warning: (ae-forgotten-export) The symbol "ReCaptchaLoader" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    readonly _recaptchaLoader: ReCaptchaLoader;
    render(): Promise<number>;
    // @internal (undocumented)
    _reset(): void;
    readonly type = "recaptcha";
    verify(): Promise<string>;
    }

// @public
export function reload(user: User): Promise<void>;

// Warning: (ae-forgotten-export) The symbol "FederatedAuthProvider" needs to be exported by the entry point index.d.ts
//
// @public
export class SAMLAuthProvider extends FederatedAuthProvider {
    constructor(providerId: string);
    static credentialFromError(error: FirebaseError): AuthCredential | null;
    static credentialFromJSON(json: string | object): AuthCredential;
    static credentialFromResult(userCredential: UserCredential): AuthCredential | null;
    }

// @public
export function sendEmailVerification(user: User, actionCodeSettings?: ActionCodeSettings | null): Promise<void>;

// @public
export function sendPasswordResetEmail(auth: Auth, email: string, actionCodeSettings?: ActionCodeSettings): Promise<void>;

// @public
export function sendSignInLinkToEmail(auth: Auth, email: string, actionCodeSettings: ActionCodeSettings): Promise<void>;

// @public
export function setPersistence(auth: Auth, persistence: Persistence): Promise<void>;

// @public
export function signInAnonymously(auth: Auth): Promise<UserCredential>;

// @public
export const SignInMethod: {
    readonly EMAIL_LINK: "emailLink";
    readonly EMAIL_PASSWORD: "password";
    readonly FACEBOOK: "facebook.com";
    readonly GITHUB: "github.com";
    readonly GOOGLE: "google.com";
    readonly PHONE: "phone";
    readonly TWITTER: "twitter.com";
};

// @public
export function signInWithCredential(auth: Auth, credential: AuthCredential): Promise<UserCredential>;

// @public
export function signInWithCustomToken(auth: Auth, customToken: string): Promise<UserCredential>;

// @public
export function signInWithEmailAndPassword(auth: Auth, email: string, password: string): Promise<UserCredential>;

// @public
export function signInWithEmailLink(auth: Auth, email: string, emailLink?: string): Promise<UserCredential>;

// @public
export function signInWithPhoneNumber(auth: Auth, phoneNumber: string, appVerifier: ApplicationVerifier): Promise<ConfirmationResult>;

// @public
export function signInWithPopup(auth: Auth, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<UserCredential>;

// @public
export function signInWithRedirect(auth: Auth, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<never>;

// @public
export function signOut(auth: Auth): Promise<void>;

// @public
export class TwitterAuthProvider extends BaseOAuthProvider {
    constructor();
    static credential(token: string, secret: string): OAuthCredential;
    static credentialFromError(error: FirebaseError): OAuthCredential | null;
    static credentialFromResult(userCredential: UserCredential): OAuthCredential | null;
    static readonly PROVIDER_ID: 'twitter.com';
    static readonly TWITTER_SIGN_IN_METHOD: 'twitter.com';
}

// @public
export function unlink(user: User, providerId: string): Promise<User>;

export { Unsubscribe }

// @public
export function updateCurrentUser(auth: Auth, user: User | null): Promise<void>;

// @public
export function updateEmail(user: User, newEmail: string): Promise<void>;

// @public
export function updatePassword(user: User, newPassword: string): Promise<void>;

// @public
export function updatePhoneNumber(user: User, credential: PhoneAuthCredential): Promise<void>;

// @public
export function updateProfile(user: User, { displayName, photoURL: photoUrl }: {
    displayName?: string | null;
    photoURL?: string | null;
}): Promise<void>;

// @public
export function useDeviceLanguage(auth: Auth): void;

// @public
export interface User extends UserInfo {
    delete(): Promise<void>;
    readonly emailVerified: boolean;
    getIdToken(forceRefresh?: boolean): Promise<string>;
    getIdTokenResult(forceRefresh?: boolean): Promise<IdTokenResult>;
    readonly isAnonymous: boolean;
    readonly metadata: UserMetadata;
    readonly providerData: UserInfo[];
    readonly refreshToken: string;
    reload(): Promise<void>;
    readonly tenantId: string | null;
    toJSON(): object;
}

// @public
export interface UserCredential {
    operationType: typeof OperationType[keyof typeof OperationType];
    providerId: string | null;
    user: User;
}

// @public
export interface UserInfo {
    readonly displayName: string | null;
    readonly email: string | null;
    readonly phoneNumber: string | null;
    readonly photoURL: string | null;
    readonly providerId: string;
    readonly uid: string;
}

// @public
export interface UserMetadata {
    readonly creationTime?: string;
    readonly lastSignInTime?: string;
}

// @public
export type UserProfile = Record<string, unknown>;

// @public
export function verifyBeforeUpdateEmail(user: User, newEmail: string, actionCodeSettings?: ActionCodeSettings | null): Promise<void>;

// @public
export function verifyPasswordResetCode(auth: Auth, code: string): Promise<string>;


```
