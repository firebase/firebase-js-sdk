## API Report File for "@firebase/firestore-lite-pipelines"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { FirebaseApp } from '@firebase/app';

// @beta
export interface Accumulator {
    // (undocumented)
    accumulator: true;
    add(other: Accumulator): Add;
    add(other: any): Add;
    arrayConcat(...arrays: Accumulator[]): ArrayConcat;
    arrayConcat(...arrays: any[][]): ArrayConcat;
    arrayContains(element: Accumulator): ArrayContains;
    arrayContains(element: any): ArrayContains;
    arrayContainsAll(...values: Accumulator[]): ArrayContainsAll;
    arrayContainsAll(...values: any[]): ArrayContainsAll;
    arrayContainsAny(...values: Accumulator[]): ArrayContainsAny;
    arrayContainsAny(...values: any[]): ArrayContainsAny;
    arrayLength(): ArrayLength;
    as(name: string): ExprWithAlias<Accumulator>;
    ascending(): Ordering;
    avg(): Avg;
    byteLength(): ByteLength;
    charLength(): CharLength;
    cosineDistance(other: Accumulator): CosineDistance;
    // Warning: (ae-forgotten-export) The symbol "VectorValue" needs to be exported by the entry point pipelines.d.ts
    cosineDistance(other: VectorValue): CosineDistance;
    cosineDistance(other: number[]): CosineDistance;
    count(): Count;
    descending(): Ordering;
    divide(other: Accumulator): Divide;
    divide(other: any): Divide;
    dotProduct(other: Accumulator): DotProduct;
    dotProduct(other: VectorValue): DotProduct;
    // (undocumented)
    dotProduct(other: number[]): DotProduct;
    endsWith(suffix: string): EndsWith;
    endsWith(suffix: Accumulator): EndsWith;
    eq(other: Accumulator): Eq;
    eq(other: any): Eq;
    eqAny(...others: Accumulator[]): EqAny;
    // (undocumented)
    eqAny(...others: any[]): EqAny;
    euclideanDistance(other: Accumulator): EuclideanDistance;
    euclideanDistance(other: VectorValue): EuclideanDistance;
    // (undocumented)
    euclideanDistance(other: number[]): EuclideanDistance;
    exists(): Exists;
    // (undocumented)
    exprType: ExprType;
    gt(other: Accumulator): Gt;
    gt(other: any): Gt;
    gte(other: Accumulator): Gte;
    gte(other: any): Gte;
    isNaN(): IsNan;
    like(pattern: string): Like;
    // (undocumented)
    like(pattern: Accumulator): Like;
    logicalMaximum(other: Accumulator): LogicalMaximum;
    logicalMaximum(other: any): LogicalMaximum;
    logicalMinimum(other: Accumulator): LogicalMinimum;
    logicalMinimum(other: any): LogicalMinimum;
    lt(other: Accumulator): Lt;
    lt(other: any): Lt;
    lte(other: Accumulator): Lte;
    lte(other: any): Lte;
    mapGet(subfield: string): MapGet;
    maximum(): Maximum;
    minimum(): Minimum;
    mod(other: Accumulator): Mod;
    mod(other: any): Mod;
    multiply(other: Accumulator): Multiply;
    multiply(other: any): Multiply;
    neq(other: Accumulator): Neq;
    neq(other: any): Neq;
    notEqAny(...others: Accumulator[]): FirestoreFunction;
    // (undocumented)
    notEqAny(...others: any[]): FirestoreFunction;
    regexContains(pattern: string): RegexContains;
    regexContains(pattern: Accumulator): RegexContains;
    regexMatch(pattern: string): RegexMatch;
    regexMatch(pattern: Accumulator): RegexMatch;
    replaceAll(find: string, replace: string): ReplaceAll;
    replaceAll(find: Accumulator, replace: Accumulator): ReplaceAll;
    replaceFirst(find: string, replace: string): ReplaceFirst;
    replaceFirst(find: Accumulator, replace: Accumulator): ReplaceFirst;
    reverse(): Reverse;
    startsWith(prefix: string): StartsWith;
    startsWith(prefix: Accumulator): StartsWith;
    strConcat(...elements: Array<string | Accumulator>): StrConcat;
    strContains(substring: string): StrContains;
    strContains(expr: Accumulator): StrContains;
    subtract(other: Accumulator): Subtract;
    subtract(other: any): Subtract;
    sum(): Sum;
    timestampAdd(unit: Accumulator, amount: Accumulator): TimestampAdd;
    timestampAdd(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampAdd;
    timestampSub(unit: Accumulator, amount: Accumulator): TimestampSub;
    timestampSub(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampSub;
    timestampToUnixMicros(): TimestampToUnixMicros;
    timestampToUnixMillis(): TimestampToUnixMillis;
    timestampToUnixSeconds(): TimestampToUnixSeconds;
    toLower(): ToLower;
    toUpper(): ToUpper;
    trim(): Trim;
    unixMicrosToTimestamp(): UnixMicrosToTimestamp;
    unixMillisToTimestamp(): UnixMillisToTimestamp;
    unixSecondsToTimestamp(): UnixSecondsToTimestamp;
    vectorLength(): VectorLength;
}

// @beta
export type AccumulatorTarget = ExprWithAlias<Accumulator>;

// @beta (undocumented)
export class Add extends FirestoreFunction {
    constructor(left: Accumulator, right: Accumulator);
    }

// @beta
export function add(left: Accumulator, right: Accumulator): Add;

// @beta
export function add(left: Accumulator, right: any): Add;

// @beta
export function add(left: string, right: Accumulator): Add;

// @beta
export function add(left: string, right: any): Add;

// @beta (undocumented)
export class AddFields implements Stage {
    constructor(fields: Map<string, Accumulator>);
    // (undocumented)
    name: string;
}

// @beta (undocumented)
export class Aggregate implements Stage {
    constructor(accumulators: Map<string, Accumulator>, groups: Map<string, Accumulator>);
    // (undocumented)
    name: string;
}

// @beta (undocumented)
export class And extends FirestoreFunction implements FilterCondition {
    constructor(conditions: (FilterCondition)[]);
    // (undocumented)
    filterable: true;
}

// @beta (undocumented)
export class ArrayConcat extends FirestoreFunction {
    constructor(array: Accumulator, elements: Accumulator[]);
    }

// @beta
export function arrayConcat(array: Accumulator, elements: Accumulator[]): ArrayConcat;

// @beta
export function arrayConcat(array: Accumulator, elements: any[]): ArrayConcat;

// @beta
export function arrayConcat(array: string, elements: Accumulator[]): ArrayConcat;

// @beta
export function arrayConcat(array: string, elements: any[]): ArrayConcat;

// @beta (undocumented)
export class ArrayContains extends FirestoreFunction implements FilterCondition {
    constructor(array: Accumulator, element: Accumulator);
    // (undocumented)
    filterable: true;
}

// @beta
export function arrayContains(array: Accumulator, element: Accumulator): ArrayContains;

// @beta
export function arrayContains(array: Accumulator, element: any): ArrayContains;

// @beta
export function arrayContains(array: string, element: Accumulator): ArrayContains;

// @beta
export function arrayContains(array: string, element: any): ArrayContains;

// @beta (undocumented)
export class ArrayContainsAll extends FirestoreFunction implements FilterCondition {
    constructor(array: Accumulator, values: Accumulator[]);
    // (undocumented)
    filterable: true;
    }

// @beta
export function arrayContainsAll(array: Accumulator, values: Accumulator[]): ArrayContainsAll;

// @beta
export function arrayContainsAll(array: Accumulator, values: any[]): ArrayContainsAll;

// @beta
export function arrayContainsAll(array: string, values: Accumulator[]): ArrayContainsAll;

// @beta
export function arrayContainsAll(array: string, values: any[]): ArrayContainsAll;

// @beta (undocumented)
export class ArrayContainsAny extends FirestoreFunction implements FilterCondition {
    constructor(array: Accumulator, values: Accumulator[]);
    // (undocumented)
    filterable: true;
    }

// @beta
export function arrayContainsAny(array: Accumulator, values: Accumulator[]): ArrayContainsAny;

// @beta
export function arrayContainsAny(array: Accumulator, values: any[]): ArrayContainsAny;

// @beta
export function arrayContainsAny(array: string, values: Accumulator[]): ArrayContainsAny;

// @beta
export function arrayContainsAny(array: string, values: any[]): ArrayContainsAny;

// @beta (undocumented)
export class ArrayElement extends FirestoreFunction {
    constructor();
}

// @beta (undocumented)
export class ArrayLength extends FirestoreFunction {
    constructor(array: Accumulator);
    }

// @beta
export function arrayLength(array: Accumulator): ArrayLength;

// @beta (undocumented)
export class ArrayReverse extends FirestoreFunction {
    constructor(array: Accumulator);
    }

// @beta
export function ascending(expr: Accumulator): Ordering;

// @beta (undocumented)
export class Avg extends FirestoreFunction implements Accumulator {
    constructor(value: Accumulator, distinct: boolean);
    // (undocumented)
    accumulator: true;
    }

// @beta (undocumented)
export class ByteLength extends FirestoreFunction {
    constructor(value: Accumulator);
    }

// @beta
export function byteLength(expr: Accumulator): ByteLength;

// @beta
export function byteLength(field: string): ByteLength;

// @beta (undocumented)
export class CharLength extends FirestoreFunction {
    constructor(value: Accumulator);
    }

// @beta
export function charLength(field: string): CharLength;

// @beta
export function charLength(expr: Accumulator): CharLength;

// @beta (undocumented)
export class CollectionGroupSource implements Stage {
    constructor(collectionId: string);
    // (undocumented)
    name: string;
}

// @beta (undocumented)
export class CollectionSource implements Stage {
    constructor(collectionPath: string);
    // (undocumented)
    name: string;
}

// @beta (undocumented)
export class Cond extends FirestoreFunction {
    constructor(condition: FilterCondition, thenExpr: Accumulator, elseExpr: Accumulator);
    // (undocumented)
    filterable: true;
    }

// @beta
export function cond(condition: FilterCondition, thenExpr: Accumulator, elseExpr: Accumulator): Cond;

// @beta
export class Constant {
    add(other: Accumulator): Add;
    add(other: any): Add;
    arrayConcat(...arrays: Accumulator[]): ArrayConcat;
    arrayConcat(...arrays: any[][]): ArrayConcat;
    arrayContains(element: Accumulator): ArrayContains;
    arrayContains(element: any): ArrayContains;
    arrayContainsAll(...values: Accumulator[]): ArrayContainsAll;
    arrayContainsAll(...values: any[]): ArrayContainsAll;
    arrayContainsAny(...values: Accumulator[]): ArrayContainsAny;
    arrayContainsAny(...values: any[]): ArrayContainsAny;
    arrayLength(): ArrayLength;
    as(name: string): ExprWithAlias<this>;
    ascending(): Ordering;
    avg(): Avg;
    byteLength(): ByteLength;
    charLength(): CharLength;
    cosineDistance(other: Accumulator): CosineDistance;
    cosineDistance(other: VectorValue): CosineDistance;
    cosineDistance(other: number[]): CosineDistance;
    count(): Count;
    descending(): Ordering;
    divide(other: Accumulator): Divide;
    divide(other: any): Divide;
    dotProduct(other: Accumulator): DotProduct;
    dotProduct(other: VectorValue): DotProduct;
    // (undocumented)
    dotProduct(other: number[]): DotProduct;
    endsWith(suffix: string): EndsWith;
    endsWith(suffix: Accumulator): EndsWith;
    eq(other: Accumulator): Eq;
    eq(other: any): Eq;
    eqAny(...others: Accumulator[]): EqAny;
    // (undocumented)
    eqAny(...others: any[]): EqAny;
    euclideanDistance(other: Accumulator): EuclideanDistance;
    euclideanDistance(other: VectorValue): EuclideanDistance;
    // (undocumented)
    euclideanDistance(other: number[]): EuclideanDistance;
    exists(): Exists;
    // (undocumented)
    exprType: ExprType;
    gt(other: Accumulator): Gt;
    gt(other: any): Gt;
    gte(other: Accumulator): Gte;
    gte(other: any): Gte;
    isNaN(): IsNan;
    like(pattern: string): Like;
    // (undocumented)
    like(pattern: Accumulator): Like;
    logicalMaximum(other: Accumulator): LogicalMaximum;
    logicalMaximum(other: any): LogicalMaximum;
    logicalMinimum(other: Accumulator): LogicalMinimum;
    logicalMinimum(other: any): LogicalMinimum;
    lt(other: Accumulator): Lt;
    lt(other: any): Lt;
    lte(other: Accumulator): Lte;
    lte(other: any): Lte;
    mapGet(subfield: string): MapGet;
    maximum(): Maximum;
    minimum(): Minimum;
    mod(other: Accumulator): Mod;
    mod(other: any): Mod;
    multiply(other: Accumulator): Multiply;
    multiply(other: any): Multiply;
    neq(other: Accumulator): Neq;
    neq(other: any): Neq;
    notEqAny(...others: Accumulator[]): FirestoreFunction;
    // (undocumented)
    notEqAny(...others: any[]): FirestoreFunction;
    static of(value: number): Constant;
    static of(value: string): Constant;
    static of(value: boolean): Constant;
    static of(value: null): Constant;
    static of(value: undefined): Constant;
    // Warning: (ae-forgotten-export) The symbol "GeoPoint" needs to be exported by the entry point pipelines.d.ts
    static of(value: GeoPoint): Constant;
    // Warning: (ae-forgotten-export) The symbol "Timestamp" needs to be exported by the entry point pipelines.d.ts
    static of(value: Timestamp): Constant;
    static of(value: Date): Constant;
    static of(value: Uint8Array): Constant;
    // Warning: (ae-forgotten-export) The symbol "DocumentReference" needs to be exported by the entry point pipelines.d.ts
    static of(value: DocumentReference): Constant;
    static of(value: any[]): Constant;
    static of(value: Map<string, any>): Constant;
    static of(value: VectorValue): Constant;
    regexContains(pattern: string): RegexContains;
    regexContains(pattern: Accumulator): RegexContains;
    regexMatch(pattern: string): RegexMatch;
    regexMatch(pattern: Accumulator): RegexMatch;
    replaceAll(find: string, replace: string): ReplaceAll;
    replaceAll(find: Accumulator, replace: Accumulator): ReplaceAll;
    replaceFirst(find: string, replace: string): ReplaceFirst;
    replaceFirst(find: Accumulator, replace: Accumulator): ReplaceFirst;
    reverse(): Reverse;
    startsWith(prefix: string): StartsWith;
    startsWith(prefix: Accumulator): StartsWith;
    strConcat(...elements: Array<string | Accumulator>): StrConcat;
    strContains(substring: string): StrContains;
    strContains(expr: Accumulator): StrContains;
    subtract(other: Accumulator): Subtract;
    subtract(other: any): Subtract;
    sum(): Sum;
    timestampAdd(unit: Accumulator, amount: Accumulator): TimestampAdd;
    timestampAdd(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampAdd;
    timestampSub(unit: Accumulator, amount: Accumulator): TimestampSub;
    timestampSub(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampSub;
    timestampToUnixMicros(): TimestampToUnixMicros;
    timestampToUnixMillis(): TimestampToUnixMillis;
    timestampToUnixSeconds(): TimestampToUnixSeconds;
    toLower(): ToLower;
    toUpper(): ToUpper;
    trim(): Trim;
    unixMicrosToTimestamp(): UnixMicrosToTimestamp;
    unixMillisToTimestamp(): UnixMillisToTimestamp;
    unixSecondsToTimestamp(): UnixSecondsToTimestamp;
    static vector(value: number[] | VectorValue): Constant;
    vectorLength(): VectorLength;
}

// @beta (undocumented)
export class CosineDistance extends FirestoreFunction {
    constructor(vector1: Accumulator, vector2: Accumulator);
    }

// @beta
export function cosineDistance(expr: string, other: number[]): CosineDistance;

// @beta
export function cosineDistance(expr: string, other: VectorValue): CosineDistance;

// @beta
export function cosineDistance(expr: string, other: Accumulator): CosineDistance;

// @beta
export function cosineDistance(expr: Accumulator, other: number[]): CosineDistance;

// @beta
export function cosineDistance(expr: Accumulator, other: VectorValue): CosineDistance;

// @beta
export function cosineDistance(expr: Accumulator, other: Accumulator): CosineDistance;

// @beta (undocumented)
export class Count extends FirestoreFunction implements Accumulator {
    constructor(value: Accumulator | undefined, distinct: boolean);
    // (undocumented)
    accumulator: true;
    }

// @beta
export function countAll(): Count;

// @beta (undocumented)
export class DatabaseSource implements Stage {
    // (undocumented)
    name: string;
}

// @beta
export function descending(expr: Accumulator): Ordering;

// @beta (undocumented)
export class Distinct implements Stage {
    constructor(groups: Map<string, Accumulator>);
    // (undocumented)
    name: string;
}

// @beta (undocumented)
export class Divide extends FirestoreFunction {
    constructor(left: Accumulator, right: Accumulator);
    }

// @beta
export function divide(left: Accumulator, right: Accumulator): Divide;

// @beta
export function divide(left: Accumulator, right: any): Divide;

// @beta
export function divide(left: string, right: Accumulator): Divide;

// @beta
export function divide(left: string, right: any): Divide;

// @beta (undocumented)
export class DocumentsSource implements Stage {
    constructor(docPaths: string[]);
    // (undocumented)
    name: string;
    // (undocumented)
    static of(refs: DocumentReference[]): DocumentsSource;
}

// @beta (undocumented)
export class DotProduct extends FirestoreFunction {
    constructor(vector1: Accumulator, vector2: Accumulator);
    }

// @beta
export function dotProduct(expr: string, other: number[]): DotProduct;

// @beta
export function dotProduct(expr: string, other: VectorValue): DotProduct;

// @beta
export function dotProduct(expr: string, other: Accumulator): DotProduct;

// @beta
export function dotProduct(expr: Accumulator, other: number[]): DotProduct;

// @beta
export function dotProduct(expr: Accumulator, other: VectorValue): DotProduct;

// @beta
export function dotProduct(expr: Accumulator, other: Accumulator): DotProduct;

// @beta (undocumented)
export class EndsWith extends FirestoreFunction implements FilterCondition {
    constructor(expr: Accumulator, suffix: Accumulator);
    // (undocumented)
    filterable: true;
    }

// @beta
export function endsWith(expr: string, suffix: string): EndsWith;

// @beta
export function endsWith(expr: string, suffix: Accumulator): EndsWith;

// @beta
export function endsWith(expr: Accumulator, suffix: string): EndsWith;

// @beta
export function endsWith(expr: Accumulator, suffix: Accumulator): EndsWith;

// @beta (undocumented)
export class Eq extends FirestoreFunction implements FilterCondition {
    constructor(left: Accumulator, right: Accumulator);
    // (undocumented)
    filterable: true;
    }

// @beta
export function eq(left: Accumulator, right: Accumulator): Eq;

// @beta
export function eq(left: Accumulator, right: any): Eq;

// @beta
export function eq(left: string, right: Accumulator): Eq;

// @beta
export function eq(left: string, right: any): Eq;

// @beta (undocumented)
export class EqAny extends FirestoreFunction implements FilterCondition {
    constructor(left: Accumulator, others: Accumulator[]);
    // (undocumented)
    filterable: true;
    }

// @beta
export function eqAny(element: Accumulator, others: Accumulator[]): EqAny;

// @beta
export function eqAny(element: Accumulator, others: any[]): EqAny;

// @beta
export function eqAny(element: string, others: Accumulator[]): EqAny;

// @beta
export function eqAny(element: string, others: any[]): EqAny;

// @beta (undocumented)
export class EuclideanDistance extends FirestoreFunction {
    constructor(vector1: Accumulator, vector2: Accumulator);
    }

// @beta
export function euclideanDistance(expr: string, other: number[]): EuclideanDistance;

// @beta
export function euclideanDistance(expr: string, other: VectorValue): EuclideanDistance;

// @beta
export function euclideanDistance(expr: string, other: Accumulator): EuclideanDistance;

// @beta
export function euclideanDistance(expr: Accumulator, other: number[]): EuclideanDistance;

// @beta
export function euclideanDistance(expr: Accumulator, other: VectorValue): EuclideanDistance;

// @beta
export function euclideanDistance(expr: Accumulator, other: Accumulator): EuclideanDistance;

// @beta
export function execute(pipeline: Pipeline): Promise<PipelineResult[]>;

// @beta (undocumented)
export class Exists extends FirestoreFunction implements FilterCondition {
    constructor(expr: Accumulator);
    // (undocumented)
    filterable: true;
}

// @beta
export function exists(value: Accumulator): Exists;

// @beta
export function exists(field: string): Exists;

// @beta
export type ExprType = 'Field' | 'Constant' | 'Function' | 'ListOfExprs' | 'ExprWithAlias';

// @beta (undocumented)
export class ExprWithAlias<T extends Accumulator> implements Selectable {
    constructor(expr: T, alias: string);
    add(other: Accumulator): Add;
    add(other: any): Add;
    // (undocumented)
    readonly alias: string;
    arrayConcat(...arrays: Accumulator[]): ArrayConcat;
    arrayConcat(...arrays: any[][]): ArrayConcat;
    arrayContains(element: Accumulator): ArrayContains;
    arrayContains(element: any): ArrayContains;
    arrayContainsAll(...values: Accumulator[]): ArrayContainsAll;
    arrayContainsAll(...values: any[]): ArrayContainsAll;
    arrayContainsAny(...values: Accumulator[]): ArrayContainsAny;
    arrayContainsAny(...values: any[]): ArrayContainsAny;
    arrayLength(): ArrayLength;
    as(name: string): ExprWithAlias<this>;
    ascending(): Ordering;
    avg(): Avg;
    byteLength(): ByteLength;
    charLength(): CharLength;
    cosineDistance(other: Accumulator): CosineDistance;
    cosineDistance(other: VectorValue): CosineDistance;
    cosineDistance(other: number[]): CosineDistance;
    count(): Count;
    descending(): Ordering;
    divide(other: Accumulator): Divide;
    divide(other: any): Divide;
    dotProduct(other: Accumulator): DotProduct;
    dotProduct(other: VectorValue): DotProduct;
    // (undocumented)
    dotProduct(other: number[]): DotProduct;
    endsWith(suffix: string): EndsWith;
    endsWith(suffix: Accumulator): EndsWith;
    eq(other: Accumulator): Eq;
    eq(other: any): Eq;
    eqAny(...others: Accumulator[]): EqAny;
    // (undocumented)
    eqAny(...others: any[]): EqAny;
    euclideanDistance(other: Accumulator): EuclideanDistance;
    euclideanDistance(other: VectorValue): EuclideanDistance;
    // (undocumented)
    euclideanDistance(other: number[]): EuclideanDistance;
    exists(): Exists;
    // (undocumented)
    readonly expr: T;
    // (undocumented)
    exprType: ExprType;
    gt(other: Accumulator): Gt;
    gt(other: any): Gt;
    gte(other: Accumulator): Gte;
    gte(other: any): Gte;
    isNaN(): IsNan;
    like(pattern: string): Like;
    // (undocumented)
    like(pattern: Accumulator): Like;
    logicalMaximum(other: Accumulator): LogicalMaximum;
    logicalMaximum(other: any): LogicalMaximum;
    logicalMinimum(other: Accumulator): LogicalMinimum;
    logicalMinimum(other: any): LogicalMinimum;
    lt(other: Accumulator): Lt;
    lt(other: any): Lt;
    lte(other: Accumulator): Lte;
    lte(other: any): Lte;
    mapGet(subfield: string): MapGet;
    maximum(): Maximum;
    minimum(): Minimum;
    mod(other: Accumulator): Mod;
    mod(other: any): Mod;
    multiply(other: Accumulator): Multiply;
    multiply(other: any): Multiply;
    neq(other: Accumulator): Neq;
    neq(other: any): Neq;
    notEqAny(...others: Accumulator[]): FirestoreFunction;
    // (undocumented)
    notEqAny(...others: any[]): FirestoreFunction;
    regexContains(pattern: string): RegexContains;
    regexContains(pattern: Accumulator): RegexContains;
    regexMatch(pattern: string): RegexMatch;
    regexMatch(pattern: Accumulator): RegexMatch;
    replaceAll(find: string, replace: string): ReplaceAll;
    replaceAll(find: Accumulator, replace: Accumulator): ReplaceAll;
    replaceFirst(find: string, replace: string): ReplaceFirst;
    replaceFirst(find: Accumulator, replace: Accumulator): ReplaceFirst;
    reverse(): Reverse;
    // (undocumented)
    selectable: true;
    startsWith(prefix: string): StartsWith;
    startsWith(prefix: Accumulator): StartsWith;
    strConcat(...elements: Array<string | Accumulator>): StrConcat;
    strContains(substring: string): StrContains;
    strContains(expr: Accumulator): StrContains;
    subtract(other: Accumulator): Subtract;
    subtract(other: any): Subtract;
    sum(): Sum;
    timestampAdd(unit: Accumulator, amount: Accumulator): TimestampAdd;
    timestampAdd(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampAdd;
    timestampSub(unit: Accumulator, amount: Accumulator): TimestampSub;
    timestampSub(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampSub;
    timestampToUnixMicros(): TimestampToUnixMicros;
    timestampToUnixMillis(): TimestampToUnixMillis;
    timestampToUnixSeconds(): TimestampToUnixSeconds;
    toLower(): ToLower;
    toUpper(): ToUpper;
    trim(): Trim;
    unixMicrosToTimestamp(): UnixMicrosToTimestamp;
    unixMillisToTimestamp(): UnixMillisToTimestamp;
    unixSecondsToTimestamp(): UnixSecondsToTimestamp;
    vectorLength(): VectorLength;
}

// @beta
export class Field implements Selectable {
    add(other: Accumulator): Add;
    add(other: any): Add;
    arrayConcat(...arrays: Accumulator[]): ArrayConcat;
    arrayConcat(...arrays: any[][]): ArrayConcat;
    arrayContains(element: Accumulator): ArrayContains;
    arrayContains(element: any): ArrayContains;
    arrayContainsAll(...values: Accumulator[]): ArrayContainsAll;
    arrayContainsAll(...values: any[]): ArrayContainsAll;
    arrayContainsAny(...values: Accumulator[]): ArrayContainsAny;
    arrayContainsAny(...values: any[]): ArrayContainsAny;
    arrayLength(): ArrayLength;
    as(name: string): ExprWithAlias<this>;
    ascending(): Ordering;
    avg(): Avg;
    byteLength(): ByteLength;
    charLength(): CharLength;
    cosineDistance(other: Accumulator): CosineDistance;
    cosineDistance(other: VectorValue): CosineDistance;
    cosineDistance(other: number[]): CosineDistance;
    count(): Count;
    descending(): Ordering;
    divide(other: Accumulator): Divide;
    divide(other: any): Divide;
    dotProduct(other: Accumulator): DotProduct;
    dotProduct(other: VectorValue): DotProduct;
    // (undocumented)
    dotProduct(other: number[]): DotProduct;
    endsWith(suffix: string): EndsWith;
    endsWith(suffix: Accumulator): EndsWith;
    eq(other: Accumulator): Eq;
    eq(other: any): Eq;
    eqAny(...others: Accumulator[]): EqAny;
    // (undocumented)
    eqAny(...others: any[]): EqAny;
    euclideanDistance(other: Accumulator): EuclideanDistance;
    euclideanDistance(other: VectorValue): EuclideanDistance;
    // (undocumented)
    euclideanDistance(other: number[]): EuclideanDistance;
    exists(): Exists;
    // (undocumented)
    exprType: ExprType;
    // (undocumented)
    fieldName(): string;
    gt(other: Accumulator): Gt;
    gt(other: any): Gt;
    gte(other: Accumulator): Gte;
    gte(other: any): Gte;
    isNaN(): IsNan;
    like(pattern: string): Like;
    // (undocumented)
    like(pattern: Accumulator): Like;
    logicalMaximum(other: Accumulator): LogicalMaximum;
    logicalMaximum(other: any): LogicalMaximum;
    logicalMinimum(other: Accumulator): LogicalMinimum;
    logicalMinimum(other: any): LogicalMinimum;
    lt(other: Accumulator): Lt;
    lt(other: any): Lt;
    lte(other: Accumulator): Lte;
    lte(other: any): Lte;
    mapGet(subfield: string): MapGet;
    maximum(): Maximum;
    minimum(): Minimum;
    mod(other: Accumulator): Mod;
    mod(other: any): Mod;
    multiply(other: Accumulator): Multiply;
    multiply(other: any): Multiply;
    neq(other: Accumulator): Neq;
    neq(other: any): Neq;
    notEqAny(...others: Accumulator[]): FirestoreFunction;
    // (undocumented)
    notEqAny(...others: any[]): FirestoreFunction;
    static of(name: string): Field;
    // Warning: (ae-forgotten-export) The symbol "FieldPath" needs to be exported by the entry point pipelines.d.ts
    //
    // (undocumented)
    static of(path: FieldPath): Field;
    // (undocumented)
    static of(pipeline: Pipeline, name: string): Field;
    regexContains(pattern: string): RegexContains;
    regexContains(pattern: Accumulator): RegexContains;
    regexMatch(pattern: string): RegexMatch;
    regexMatch(pattern: Accumulator): RegexMatch;
    replaceAll(find: string, replace: string): ReplaceAll;
    replaceAll(find: Accumulator, replace: Accumulator): ReplaceAll;
    replaceFirst(find: string, replace: string): ReplaceFirst;
    replaceFirst(find: Accumulator, replace: Accumulator): ReplaceFirst;
    reverse(): Reverse;
    // (undocumented)
    selectable: true;
    startsWith(prefix: string): StartsWith;
    startsWith(prefix: Accumulator): StartsWith;
    strConcat(...elements: Array<string | Accumulator>): StrConcat;
    strContains(substring: string): StrContains;
    strContains(expr: Accumulator): StrContains;
    subtract(other: Accumulator): Subtract;
    subtract(other: any): Subtract;
    sum(): Sum;
    timestampAdd(unit: Accumulator, amount: Accumulator): TimestampAdd;
    timestampAdd(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampAdd;
    timestampSub(unit: Accumulator, amount: Accumulator): TimestampSub;
    timestampSub(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampSub;
    timestampToUnixMicros(): TimestampToUnixMicros;
    timestampToUnixMillis(): TimestampToUnixMillis;
    timestampToUnixSeconds(): TimestampToUnixSeconds;
    toLower(): ToLower;
    toUpper(): ToUpper;
    trim(): Trim;
    unixMicrosToTimestamp(): UnixMicrosToTimestamp;
    unixMillisToTimestamp(): UnixMillisToTimestamp;
    unixSecondsToTimestamp(): UnixSecondsToTimestamp;
    vectorLength(): VectorLength;
}

// @beta (undocumented)
export class Fields implements Selectable {
    add(other: Accumulator): Add;
    add(other: any): Add;
    arrayConcat(...arrays: Accumulator[]): ArrayConcat;
    arrayConcat(...arrays: any[][]): ArrayConcat;
    arrayContains(element: Accumulator): ArrayContains;
    arrayContains(element: any): ArrayContains;
    arrayContainsAll(...values: Accumulator[]): ArrayContainsAll;
    arrayContainsAll(...values: any[]): ArrayContainsAll;
    arrayContainsAny(...values: Accumulator[]): ArrayContainsAny;
    arrayContainsAny(...values: any[]): ArrayContainsAny;
    arrayLength(): ArrayLength;
    as(name: string): ExprWithAlias<this>;
    ascending(): Ordering;
    avg(): Avg;
    byteLength(): ByteLength;
    charLength(): CharLength;
    cosineDistance(other: Accumulator): CosineDistance;
    cosineDistance(other: VectorValue): CosineDistance;
    cosineDistance(other: number[]): CosineDistance;
    count(): Count;
    descending(): Ordering;
    divide(other: Accumulator): Divide;
    divide(other: any): Divide;
    dotProduct(other: Accumulator): DotProduct;
    dotProduct(other: VectorValue): DotProduct;
    // (undocumented)
    dotProduct(other: number[]): DotProduct;
    endsWith(suffix: string): EndsWith;
    endsWith(suffix: Accumulator): EndsWith;
    eq(other: Accumulator): Eq;
    eq(other: any): Eq;
    eqAny(...others: Accumulator[]): EqAny;
    // (undocumented)
    eqAny(...others: any[]): EqAny;
    euclideanDistance(other: Accumulator): EuclideanDistance;
    euclideanDistance(other: VectorValue): EuclideanDistance;
    // (undocumented)
    euclideanDistance(other: number[]): EuclideanDistance;
    exists(): Exists;
    // (undocumented)
    exprType: ExprType;
    // (undocumented)
    fieldList(): Field[];
    gt(other: Accumulator): Gt;
    gt(other: any): Gt;
    gte(other: Accumulator): Gte;
    gte(other: any): Gte;
    isNaN(): IsNan;
    like(pattern: string): Like;
    // (undocumented)
    like(pattern: Accumulator): Like;
    logicalMaximum(other: Accumulator): LogicalMaximum;
    logicalMaximum(other: any): LogicalMaximum;
    logicalMinimum(other: Accumulator): LogicalMinimum;
    logicalMinimum(other: any): LogicalMinimum;
    lt(other: Accumulator): Lt;
    lt(other: any): Lt;
    lte(other: Accumulator): Lte;
    lte(other: any): Lte;
    mapGet(subfield: string): MapGet;
    maximum(): Maximum;
    minimum(): Minimum;
    mod(other: Accumulator): Mod;
    mod(other: any): Mod;
    multiply(other: Accumulator): Multiply;
    multiply(other: any): Multiply;
    neq(other: Accumulator): Neq;
    neq(other: any): Neq;
    notEqAny(...others: Accumulator[]): FirestoreFunction;
    // (undocumented)
    notEqAny(...others: any[]): FirestoreFunction;
    // (undocumented)
    static of(name: string, ...others: string[]): Fields;
    // (undocumented)
    static ofAll(): Fields;
    regexContains(pattern: string): RegexContains;
    regexContains(pattern: Accumulator): RegexContains;
    regexMatch(pattern: string): RegexMatch;
    regexMatch(pattern: Accumulator): RegexMatch;
    replaceAll(find: string, replace: string): ReplaceAll;
    replaceAll(find: Accumulator, replace: Accumulator): ReplaceAll;
    replaceFirst(find: string, replace: string): ReplaceFirst;
    replaceFirst(find: Accumulator, replace: Accumulator): ReplaceFirst;
    reverse(): Reverse;
    // (undocumented)
    selectable: true;
    startsWith(prefix: string): StartsWith;
    startsWith(prefix: Accumulator): StartsWith;
    strConcat(...elements: Array<string | Accumulator>): StrConcat;
    strContains(substring: string): StrContains;
    strContains(expr: Accumulator): StrContains;
    subtract(other: Accumulator): Subtract;
    subtract(other: any): Subtract;
    sum(): Sum;
    timestampAdd(unit: Accumulator, amount: Accumulator): TimestampAdd;
    timestampAdd(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampAdd;
    timestampSub(unit: Accumulator, amount: Accumulator): TimestampSub;
    timestampSub(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampSub;
    timestampToUnixMicros(): TimestampToUnixMicros;
    timestampToUnixMillis(): TimestampToUnixMillis;
    timestampToUnixSeconds(): TimestampToUnixSeconds;
    toLower(): ToLower;
    toUpper(): ToUpper;
    trim(): Trim;
    unixMicrosToTimestamp(): UnixMicrosToTimestamp;
    unixMillisToTimestamp(): UnixMillisToTimestamp;
    unixSecondsToTimestamp(): UnixSecondsToTimestamp;
    vectorLength(): VectorLength;
}

// @beta
export interface FilterCondition {
    add(other: Accumulator): Add;
    add(other: any): Add;
    arrayConcat(...arrays: Accumulator[]): ArrayConcat;
    arrayConcat(...arrays: any[][]): ArrayConcat;
    arrayContains(element: Accumulator): ArrayContains;
    arrayContains(element: any): ArrayContains;
    arrayContainsAll(...values: Accumulator[]): ArrayContainsAll;
    arrayContainsAll(...values: any[]): ArrayContainsAll;
    arrayContainsAny(...values: Accumulator[]): ArrayContainsAny;
    arrayContainsAny(...values: any[]): ArrayContainsAny;
    arrayLength(): ArrayLength;
    as(name: string): ExprWithAlias<Accumulator>;
    ascending(): Ordering;
    avg(): Avg;
    byteLength(): ByteLength;
    charLength(): CharLength;
    cosineDistance(other: Accumulator): CosineDistance;
    cosineDistance(other: VectorValue): CosineDistance;
    cosineDistance(other: number[]): CosineDistance;
    count(): Count;
    descending(): Ordering;
    divide(other: Accumulator): Divide;
    divide(other: any): Divide;
    dotProduct(other: Accumulator): DotProduct;
    dotProduct(other: VectorValue): DotProduct;
    // (undocumented)
    dotProduct(other: number[]): DotProduct;
    endsWith(suffix: string): EndsWith;
    endsWith(suffix: Accumulator): EndsWith;
    eq(other: Accumulator): Eq;
    eq(other: any): Eq;
    eqAny(...others: Accumulator[]): EqAny;
    // (undocumented)
    eqAny(...others: any[]): EqAny;
    euclideanDistance(other: Accumulator): EuclideanDistance;
    euclideanDistance(other: VectorValue): EuclideanDistance;
    // (undocumented)
    euclideanDistance(other: number[]): EuclideanDistance;
    exists(): Exists;
    // (undocumented)
    exprType: ExprType;
    // (undocumented)
    filterable: true;
    gt(other: Accumulator): Gt;
    gt(other: any): Gt;
    gte(other: Accumulator): Gte;
    gte(other: any): Gte;
    isNaN(): IsNan;
    like(pattern: string): Like;
    // (undocumented)
    like(pattern: Accumulator): Like;
    logicalMaximum(other: Accumulator): LogicalMaximum;
    logicalMaximum(other: any): LogicalMaximum;
    logicalMinimum(other: Accumulator): LogicalMinimum;
    logicalMinimum(other: any): LogicalMinimum;
    lt(other: Accumulator): Lt;
    lt(other: any): Lt;
    lte(other: Accumulator): Lte;
    lte(other: any): Lte;
    mapGet(subfield: string): MapGet;
    maximum(): Maximum;
    minimum(): Minimum;
    mod(other: Accumulator): Mod;
    mod(other: any): Mod;
    multiply(other: Accumulator): Multiply;
    multiply(other: any): Multiply;
    neq(other: Accumulator): Neq;
    neq(other: any): Neq;
    notEqAny(...others: Accumulator[]): FirestoreFunction;
    // (undocumented)
    notEqAny(...others: any[]): FirestoreFunction;
    regexContains(pattern: string): RegexContains;
    regexContains(pattern: Accumulator): RegexContains;
    regexMatch(pattern: string): RegexMatch;
    regexMatch(pattern: Accumulator): RegexMatch;
    replaceAll(find: string, replace: string): ReplaceAll;
    replaceAll(find: Accumulator, replace: Accumulator): ReplaceAll;
    replaceFirst(find: string, replace: string): ReplaceFirst;
    replaceFirst(find: Accumulator, replace: Accumulator): ReplaceFirst;
    reverse(): Reverse;
    startsWith(prefix: string): StartsWith;
    startsWith(prefix: Accumulator): StartsWith;
    strConcat(...elements: Array<string | Accumulator>): StrConcat;
    strContains(substring: string): StrContains;
    strContains(expr: Accumulator): StrContains;
    subtract(other: Accumulator): Subtract;
    subtract(other: any): Subtract;
    sum(): Sum;
    timestampAdd(unit: Accumulator, amount: Accumulator): TimestampAdd;
    timestampAdd(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampAdd;
    timestampSub(unit: Accumulator, amount: Accumulator): TimestampSub;
    timestampSub(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampSub;
    timestampToUnixMicros(): TimestampToUnixMicros;
    timestampToUnixMillis(): TimestampToUnixMillis;
    timestampToUnixSeconds(): TimestampToUnixSeconds;
    toLower(): ToLower;
    toUpper(): ToUpper;
    trim(): Trim;
    unixMicrosToTimestamp(): UnixMicrosToTimestamp;
    unixMillisToTimestamp(): UnixMillisToTimestamp;
    unixSecondsToTimestamp(): UnixSecondsToTimestamp;
    vectorLength(): VectorLength;
}

// @beta (undocumented)
export class FindNearest implements Stage {
    // (undocumented)
    name: string;
}

// @beta (undocumented)
export interface FindNearestOptions {
    // (undocumented)
    distanceField?: string;
    // (undocumented)
    distanceMeasure: 'euclidean' | 'cosine' | 'dot_product';
    // (undocumented)
    field: Field;
    // (undocumented)
    limit?: number;
    // (undocumented)
    vectorValue: VectorValue | number[];
}

// @beta
export class FirestoreFunction {
    constructor(name: string, params: Accumulator[]);
    add(other: Accumulator): Add;
    add(other: any): Add;
    arrayConcat(...arrays: Accumulator[]): ArrayConcat;
    arrayConcat(...arrays: any[][]): ArrayConcat;
    arrayContains(element: Accumulator): ArrayContains;
    arrayContains(element: any): ArrayContains;
    arrayContainsAll(...values: Accumulator[]): ArrayContainsAll;
    arrayContainsAll(...values: any[]): ArrayContainsAll;
    arrayContainsAny(...values: Accumulator[]): ArrayContainsAny;
    arrayContainsAny(...values: any[]): ArrayContainsAny;
    arrayLength(): ArrayLength;
    as(name: string): ExprWithAlias<this>;
    ascending(): Ordering;
    avg(): Avg;
    byteLength(): ByteLength;
    charLength(): CharLength;
    cosineDistance(other: Accumulator): CosineDistance;
    cosineDistance(other: VectorValue): CosineDistance;
    cosineDistance(other: number[]): CosineDistance;
    count(): Count;
    descending(): Ordering;
    divide(other: Accumulator): Divide;
    divide(other: any): Divide;
    dotProduct(other: Accumulator): DotProduct;
    dotProduct(other: VectorValue): DotProduct;
    // (undocumented)
    dotProduct(other: number[]): DotProduct;
    endsWith(suffix: string): EndsWith;
    endsWith(suffix: Accumulator): EndsWith;
    eq(other: Accumulator): Eq;
    eq(other: any): Eq;
    eqAny(...others: Accumulator[]): EqAny;
    // (undocumented)
    eqAny(...others: any[]): EqAny;
    euclideanDistance(other: Accumulator): EuclideanDistance;
    euclideanDistance(other: VectorValue): EuclideanDistance;
    // (undocumented)
    euclideanDistance(other: number[]): EuclideanDistance;
    exists(): Exists;
    // (undocumented)
    exprType: ExprType;
    gt(other: Accumulator): Gt;
    gt(other: any): Gt;
    gte(other: Accumulator): Gte;
    gte(other: any): Gte;
    isNaN(): IsNan;
    like(pattern: string): Like;
    // (undocumented)
    like(pattern: Accumulator): Like;
    logicalMaximum(other: Accumulator): LogicalMaximum;
    logicalMaximum(other: any): LogicalMaximum;
    logicalMinimum(other: Accumulator): LogicalMinimum;
    logicalMinimum(other: any): LogicalMinimum;
    lt(other: Accumulator): Lt;
    lt(other: any): Lt;
    lte(other: Accumulator): Lte;
    lte(other: any): Lte;
    mapGet(subfield: string): MapGet;
    maximum(): Maximum;
    minimum(): Minimum;
    mod(other: Accumulator): Mod;
    mod(other: any): Mod;
    multiply(other: Accumulator): Multiply;
    multiply(other: any): Multiply;
    neq(other: Accumulator): Neq;
    neq(other: any): Neq;
    notEqAny(...others: Accumulator[]): FirestoreFunction;
    // (undocumented)
    notEqAny(...others: any[]): FirestoreFunction;
    regexContains(pattern: string): RegexContains;
    regexContains(pattern: Accumulator): RegexContains;
    regexMatch(pattern: string): RegexMatch;
    regexMatch(pattern: Accumulator): RegexMatch;
    replaceAll(find: string, replace: string): ReplaceAll;
    replaceAll(find: Accumulator, replace: Accumulator): ReplaceAll;
    replaceFirst(find: string, replace: string): ReplaceFirst;
    replaceFirst(find: Accumulator, replace: Accumulator): ReplaceFirst;
    reverse(): Reverse;
    startsWith(prefix: string): StartsWith;
    startsWith(prefix: Accumulator): StartsWith;
    strConcat(...elements: Array<string | Accumulator>): StrConcat;
    strContains(substring: string): StrContains;
    strContains(expr: Accumulator): StrContains;
    subtract(other: Accumulator): Subtract;
    subtract(other: any): Subtract;
    sum(): Sum;
    timestampAdd(unit: Accumulator, amount: Accumulator): TimestampAdd;
    timestampAdd(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampAdd;
    timestampSub(unit: Accumulator, amount: Accumulator): TimestampSub;
    timestampSub(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampSub;
    timestampToUnixMicros(): TimestampToUnixMicros;
    timestampToUnixMillis(): TimestampToUnixMillis;
    timestampToUnixSeconds(): TimestampToUnixSeconds;
    toLower(): ToLower;
    toUpper(): ToUpper;
    trim(): Trim;
    unixMicrosToTimestamp(): UnixMicrosToTimestamp;
    unixMillisToTimestamp(): UnixMillisToTimestamp;
    unixSecondsToTimestamp(): UnixSecondsToTimestamp;
    vectorLength(): VectorLength;
}

// @beta
export function genericFunction(name: string, params: Accumulator[]): FirestoreFunction;

// @beta (undocumented)
export class GenericStage implements Stage {
    constructor(name: string, params: unknown[]);
    // (undocumented)
    name: string;
}

// @beta (undocumented)
export class Gt extends FirestoreFunction implements FilterCondition {
    constructor(left: Accumulator, right: Accumulator);
    // (undocumented)
    filterable: true;
    }

// @beta
export function gt(left: Accumulator, right: Accumulator): Gt;

// @beta
export function gt(left: Accumulator, right: any): Gt;

// @beta
export function gt(left: string, right: Accumulator): Gt;

// @beta
export function gt(left: string, right: any): Gt;

// @beta (undocumented)
export class Gte extends FirestoreFunction implements FilterCondition {
    constructor(left: Accumulator, right: Accumulator);
    // (undocumented)
    filterable: true;
    }

// @beta
export function gte(left: Accumulator, right: Accumulator): Gte;

// @beta
export function gte(left: Accumulator, right: any): Gte;

// @beta
export function gte(left: string, right: Accumulator): Gte;

// @beta
export function gte(left: string, right: any): Gte;

// @beta (undocumented)
export class IsNan extends FirestoreFunction implements FilterCondition {
    constructor(expr: Accumulator);
    // (undocumented)
    filterable: true;
}

// @beta
export function isNan(value: Accumulator): IsNan;

// @beta
export function isNan(value: string): IsNan;

// @beta (undocumented)
export class Like extends FirestoreFunction implements FilterCondition {
    constructor(expr: Accumulator, pattern: Accumulator);
    // (undocumented)
    filterable: true;
    }

// @beta
export function like(left: string, pattern: string): Like;

// @beta
export function like(left: string, pattern: Accumulator): Like;

// @beta
export function like(left: Accumulator, pattern: string): Like;

// @beta
export function like(left: Accumulator, pattern: Accumulator): Like;

// @beta (undocumented)
export class Limit implements Stage {
    constructor(limit: number);
    // (undocumented)
    name: string;
}

// @beta (undocumented)
export class LogicalMaximum extends FirestoreFunction {
    constructor(left: Accumulator, right: Accumulator);
    }

// @beta
export function logicalMaximum(left: Accumulator, right: Accumulator): LogicalMaximum;

// @beta
export function logicalMaximum(left: Accumulator, right: any): LogicalMaximum;

// @beta
export function logicalMaximum(left: string, right: Accumulator): LogicalMaximum;

// @beta
export function logicalMaximum(left: string, right: any): LogicalMaximum;

// @beta (undocumented)
export class LogicalMinimum extends FirestoreFunction {
    constructor(left: Accumulator, right: Accumulator);
    }

// @beta
export function logicalMinimum(left: Accumulator, right: Accumulator): LogicalMinimum;

// @beta
export function logicalMinimum(left: Accumulator, right: any): LogicalMinimum;

// @beta
export function logicalMinimum(left: string, right: Accumulator): LogicalMinimum;

// @beta
export function logicalMinimum(left: string, right: any): LogicalMinimum;

// @beta (undocumented)
export class Lt extends FirestoreFunction implements FilterCondition {
    constructor(left: Accumulator, right: Accumulator);
    // (undocumented)
    filterable: true;
    }

// @beta
export function lt(left: Accumulator, right: Accumulator): Lt;

// @beta
export function lt(left: Accumulator, right: any): Lt;

// @beta
export function lt(left: string, right: Accumulator): Lt;

// @beta
export function lt(left: string, right: any): Lt;

// @beta (undocumented)
export class Lte extends FirestoreFunction implements FilterCondition {
    constructor(left: Accumulator, right: Accumulator);
    // (undocumented)
    filterable: true;
    }

// @beta
export function lte(left: Accumulator, right: Accumulator): Lte;

// @beta
export function lte(left: Accumulator, right: any): Lte;

// Warning: (ae-incompatible-release-tags) The symbol "lte" is marked as @public, but its signature references "Accumulator" which is marked as @beta
// Warning: (ae-incompatible-release-tags) The symbol "lte" is marked as @public, but its signature references "Lte" which is marked as @beta
//
// @public
export function lte(left: string, right: Accumulator): Lte;

// @beta
export function lte(left: string, right: any): Lte;

// @beta (undocumented)
export class MapGet extends FirestoreFunction {
    constructor(map: Accumulator, name: string);
}

// @beta
export function mapGet(mapField: string, subField: string): MapGet;

// @beta
export function mapGet(mapExpr: Accumulator, subField: string): MapGet;

// @beta (undocumented)
export class Maximum extends FirestoreFunction implements Accumulator {
    constructor(value: Accumulator, distinct: boolean);
    // (undocumented)
    accumulator: true;
    }

// @beta
export function maximum(value: Accumulator): Maximum;

// @beta
export function maximum(value: string): Maximum;

// @beta (undocumented)
export class Minimum extends FirestoreFunction implements Accumulator {
    constructor(value: Accumulator, distinct: boolean);
    // (undocumented)
    accumulator: true;
    }

// @beta
export function minimum(value: Accumulator): Minimum;

// @beta
export function minimum(value: string): Minimum;

// @beta (undocumented)
export class Mod extends FirestoreFunction {
    constructor(left: Accumulator, right: Accumulator);
    }

// @beta
export function mod(left: Accumulator, right: Accumulator): Mod;

// @beta
export function mod(left: Accumulator, right: any): Mod;

// @beta
export function mod(left: string, right: Accumulator): Mod;

// @beta
export function mod(left: string, right: any): Mod;

// @beta (undocumented)
export class Multiply extends FirestoreFunction {
    constructor(left: Accumulator, right: Accumulator);
    }

// @beta
export function multiply(left: Accumulator, right: Accumulator): Multiply;

// @beta
export function multiply(left: Accumulator, right: any): Multiply;

// @beta
export function multiply(left: string, right: Accumulator): Multiply;

// @beta
export function multiply(left: string, right: any): Multiply;

// @beta (undocumented)
export class Neq extends FirestoreFunction implements FilterCondition {
    constructor(left: Accumulator, right: Accumulator);
    // (undocumented)
    filterable: true;
    }

// @beta
export function neq(left: Accumulator, right: Accumulator): Neq;

// @beta
export function neq(left: Accumulator, right: any): Neq;

// @beta
export function neq(left: string, right: Accumulator): Neq;

// @beta
export function neq(left: string, right: any): Neq;

// @beta (undocumented)
export class Not extends FirestoreFunction implements FilterCondition {
    constructor(expr: Accumulator);
    // (undocumented)
    filterable: true;
}

// @beta
export function not(filter: FilterCondition): Not;

// @beta
export function notEqAny(element: Accumulator, others: Accumulator[]): FirestoreFunction;

// @beta
export function notEqAny(element: Accumulator, others: any[]): FirestoreFunction;

// @beta
export function notEqAny(element: string, others: Accumulator[]): FirestoreFunction;

// @beta
export function notEqAny(element: string, others: any[]): FirestoreFunction;

// @beta (undocumented)
export class Offset implements Stage {
    constructor(offset: number);
    // (undocumented)
    name: string;
    }

// @beta (undocumented)
export class Or extends FirestoreFunction implements FilterCondition {
    constructor(conditions: (FilterCondition)[]);
    // (undocumented)
    filterable: true;
}

// @beta
export class Ordering {
    constructor(expr: Accumulator, direction: 'ascending' | 'descending');
    // (undocumented)
    readonly direction: 'ascending' | 'descending';
    // (undocumented)
    readonly expr: Accumulator;
}

// @public
export class Pipeline {
    /* Excluded from this release type: _db */
    // Warning: (ae-incompatible-release-tags) The symbol "addFields" is marked as @public, but its signature references "Selectable" which is marked as @beta
    addFields(...fields: Selectable[]): Pipeline;
    /* Excluded from this release type: _userDataWriter */
    // Warning: (ae-incompatible-release-tags) The symbol "aggregate" is marked as @public, but its signature references "AccumulatorTarget" which is marked as @beta
    aggregate(...accumulators: AccumulatorTarget[]): Pipeline;
    /* Excluded from this release type: _userDataWriter */
    aggregate(options: {
        accumulators: AccumulatorTarget[];
        groups?: Array<string | Selectable>;
    }): Pipeline;
    /* Excluded from this release type: _userDataWriter */
    // Warning: (ae-incompatible-release-tags) The symbol "distinct" is marked as @public, but its signature references "Selectable" which is marked as @beta
    distinct(...groups: Array<string | (Selectable)>): Pipeline;
    /* Excluded from this release type: _userDataWriter */
    // Warning: (ae-incompatible-release-tags) The symbol "execute" is marked as @public, but its signature references "PipelineResult" which is marked as @beta
    execute(): Promise<PipelineResult[]>;
    /* Excluded from this release type: _userDataWriter */
    // Warning: (ae-incompatible-release-tags) The symbol "findNearest" is marked as @public, but its signature references "FindNearestOptions" which is marked as @beta
    //
    // (undocumented)
    findNearest(options: FindNearestOptions): Pipeline;
    /* Excluded from this release type: _userDataWriter */
    genericStage(name: string, params: any[]): Pipeline;
    /* Excluded from this release type: _userDataWriter */
    limit(limit: number): Pipeline;
    /* Excluded from this release type: _userDataWriter */
    offset(offset: number): Pipeline;
    /* Excluded from this release type: _userDataWriter */
    // Warning: (ae-incompatible-release-tags) The symbol "select" is marked as @public, but its signature references "Selectable" which is marked as @beta
    select(...selections: Array<Selectable | string>): Pipeline;
    /* Excluded from this release type: _userDataWriter */
    // Warning: (ae-incompatible-release-tags) The symbol "sort" is marked as @public, but its signature references "Ordering" which is marked as @beta
    sort(...orderings: Ordering[]): Pipeline;
    /* Excluded from this release type: _userDataWriter */
    // (undocumented)
    sort(options: {
        orderings: Ordering[];
    }): Pipeline;
    /* Excluded from this release type: _userDataWriter */
    // Warning: (ae-incompatible-release-tags) The symbol "where" is marked as @public, but its signature references "FilterCondition" which is marked as @beta
    where(condition: FilterCondition): Pipeline;
}

// Warning: (ae-forgotten-export) The symbol "Firestore" needs to be exported by the entry point pipelines.d.ts
// Warning: (ae-incompatible-release-tags) The symbol "pipeline" is marked as @public, but its signature references "PipelineSource" which is marked as @beta
//
// @public
export function pipeline(firestore: Firestore): PipelineSource<Pipeline>;

// Warning: (ae-forgotten-export) The symbol "Query" needs to be exported by the entry point pipelines.d.ts
//
// @public
export function pipeline(query: Query): Pipeline;

// Warning: (ae-forgotten-export) The symbol "DocumentData" needs to be exported by the entry point pipelines.d.ts
//
// @beta
export class PipelineResult<AppModelType = DocumentData> {
    /* Excluded from this release type: _ref */
    /* Excluded from this release type: _fields */
    /* Excluded from this release type: __constructor */
    get createTime(): Timestamp | undefined;
    data(): AppModelType | undefined;
    get executionTime(): Timestamp;
    get(fieldPath: string | FieldPath): any;
    get id(): string | undefined;
    get ref(): DocumentReference | undefined;
    get updateTime(): Timestamp | undefined;
}

// @beta
export class PipelineSource<PipelineType> {
    /* Excluded from this release type: _createPipeline */
    /* Excluded from this release type: __constructor */
    // (undocumented)
    collection(collectionPath: string): PipelineType;
    // (undocumented)
    collectionGroup(collectionId: string): PipelineType;
    // (undocumented)
    database(): PipelineType;
    // (undocumented)
    documents(docs: DocumentReference[]): PipelineType;
}

// @beta (undocumented)
export class RegexContains extends FirestoreFunction implements FilterCondition {
    constructor(expr: Accumulator, pattern: Accumulator);
    // (undocumented)
    filterable: true;
    }

// @beta
export function regexContains(left: string, pattern: string): RegexContains;

// @beta
export function regexContains(left: string, pattern: Accumulator): RegexContains;

// @beta
export function regexContains(left: Accumulator, pattern: string): RegexContains;

// @beta
export function regexContains(left: Accumulator, pattern: Accumulator): RegexContains;

// @beta (undocumented)
export class RegexMatch extends FirestoreFunction implements FilterCondition {
    constructor(expr: Accumulator, pattern: Accumulator);
    // (undocumented)
    filterable: true;
    }

// @beta
export function regexMatch(left: string, pattern: string): RegexMatch;

// @beta
export function regexMatch(left: string, pattern: Accumulator): RegexMatch;

// @beta
export function regexMatch(left: Accumulator, pattern: string): RegexMatch;

// @beta
export function regexMatch(left: Accumulator, pattern: Accumulator): RegexMatch;

// @beta (undocumented)
export class ReplaceAll extends FirestoreFunction {
    constructor(value: Accumulator, find: Accumulator, replace: Accumulator);
    }

// @beta
export function replaceAll(value: Accumulator, find: string, replace: string): ReplaceAll;

// @beta
export function replaceAll(value: Accumulator, find: Accumulator, replace: Accumulator): ReplaceAll;

// @beta
export function replaceAll(field: string, find: string, replace: string): ReplaceAll;

// @beta (undocumented)
export class ReplaceFirst extends FirestoreFunction {
    constructor(value: Accumulator, find: Accumulator, replace: Accumulator);
    }

// @beta
export function replaceFirst(value: Accumulator, find: string, replace: string): ReplaceFirst;

// @beta
export function replaceFirst(value: Accumulator, find: Accumulator, replace: Accumulator): ReplaceFirst;

// @beta
export function replaceFirst(field: string, find: string, replace: string): ReplaceFirst;

// @beta (undocumented)
export class Reverse extends FirestoreFunction {
    constructor(value: Accumulator);
    }

// @beta
export function reverse(expr: Accumulator): Reverse;

// @beta
export function reverse(field: string): Reverse;

// @beta (undocumented)
export class Select implements Stage {
    constructor(projections: Map<string, Accumulator>);
    // (undocumented)
    name: string;
    }

// @beta
export interface Selectable {
    add(other: Accumulator): Add;
    add(other: any): Add;
    arrayConcat(...arrays: Accumulator[]): ArrayConcat;
    arrayConcat(...arrays: any[][]): ArrayConcat;
    arrayContains(element: Accumulator): ArrayContains;
    arrayContains(element: any): ArrayContains;
    arrayContainsAll(...values: Accumulator[]): ArrayContainsAll;
    arrayContainsAll(...values: any[]): ArrayContainsAll;
    arrayContainsAny(...values: Accumulator[]): ArrayContainsAny;
    arrayContainsAny(...values: any[]): ArrayContainsAny;
    arrayLength(): ArrayLength;
    as(name: string): ExprWithAlias<Accumulator>;
    ascending(): Ordering;
    avg(): Avg;
    byteLength(): ByteLength;
    charLength(): CharLength;
    cosineDistance(other: Accumulator): CosineDistance;
    cosineDistance(other: VectorValue): CosineDistance;
    cosineDistance(other: number[]): CosineDistance;
    count(): Count;
    descending(): Ordering;
    divide(other: Accumulator): Divide;
    divide(other: any): Divide;
    dotProduct(other: Accumulator): DotProduct;
    dotProduct(other: VectorValue): DotProduct;
    // (undocumented)
    dotProduct(other: number[]): DotProduct;
    endsWith(suffix: string): EndsWith;
    endsWith(suffix: Accumulator): EndsWith;
    eq(other: Accumulator): Eq;
    eq(other: any): Eq;
    eqAny(...others: Accumulator[]): EqAny;
    // (undocumented)
    eqAny(...others: any[]): EqAny;
    euclideanDistance(other: Accumulator): EuclideanDistance;
    euclideanDistance(other: VectorValue): EuclideanDistance;
    // (undocumented)
    euclideanDistance(other: number[]): EuclideanDistance;
    exists(): Exists;
    // (undocumented)
    exprType: ExprType;
    gt(other: Accumulator): Gt;
    gt(other: any): Gt;
    gte(other: Accumulator): Gte;
    gte(other: any): Gte;
    isNaN(): IsNan;
    like(pattern: string): Like;
    // (undocumented)
    like(pattern: Accumulator): Like;
    logicalMaximum(other: Accumulator): LogicalMaximum;
    logicalMaximum(other: any): LogicalMaximum;
    logicalMinimum(other: Accumulator): LogicalMinimum;
    logicalMinimum(other: any): LogicalMinimum;
    lt(other: Accumulator): Lt;
    lt(other: any): Lt;
    lte(other: Accumulator): Lte;
    lte(other: any): Lte;
    mapGet(subfield: string): MapGet;
    maximum(): Maximum;
    minimum(): Minimum;
    mod(other: Accumulator): Mod;
    mod(other: any): Mod;
    multiply(other: Accumulator): Multiply;
    multiply(other: any): Multiply;
    neq(other: Accumulator): Neq;
    neq(other: any): Neq;
    notEqAny(...others: Accumulator[]): FirestoreFunction;
    // (undocumented)
    notEqAny(...others: any[]): FirestoreFunction;
    regexContains(pattern: string): RegexContains;
    regexContains(pattern: Accumulator): RegexContains;
    regexMatch(pattern: string): RegexMatch;
    regexMatch(pattern: Accumulator): RegexMatch;
    replaceAll(find: string, replace: string): ReplaceAll;
    replaceAll(find: Accumulator, replace: Accumulator): ReplaceAll;
    replaceFirst(find: string, replace: string): ReplaceFirst;
    replaceFirst(find: Accumulator, replace: Accumulator): ReplaceFirst;
    reverse(): Reverse;
    // (undocumented)
    selectable: true;
    startsWith(prefix: string): StartsWith;
    startsWith(prefix: Accumulator): StartsWith;
    strConcat(...elements: Array<string | Accumulator>): StrConcat;
    strContains(substring: string): StrContains;
    strContains(expr: Accumulator): StrContains;
    subtract(other: Accumulator): Subtract;
    subtract(other: any): Subtract;
    sum(): Sum;
    timestampAdd(unit: Accumulator, amount: Accumulator): TimestampAdd;
    timestampAdd(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampAdd;
    timestampSub(unit: Accumulator, amount: Accumulator): TimestampSub;
    timestampSub(unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampSub;
    timestampToUnixMicros(): TimestampToUnixMicros;
    timestampToUnixMillis(): TimestampToUnixMillis;
    timestampToUnixSeconds(): TimestampToUnixSeconds;
    toLower(): ToLower;
    toUpper(): ToUpper;
    trim(): Trim;
    unixMicrosToTimestamp(): UnixMicrosToTimestamp;
    unixMillisToTimestamp(): UnixMillisToTimestamp;
    unixSecondsToTimestamp(): UnixSecondsToTimestamp;
    vectorLength(): VectorLength;
}

// @beta (undocumented)
export class Sort implements Stage {
    constructor(orders: Ordering[]);
    // (undocumented)
    name: string;
    }

// @beta (undocumented)
export interface Stage {
    // (undocumented)
    name: string;
}

// @beta (undocumented)
export class StartsWith extends FirestoreFunction implements FilterCondition {
    constructor(expr: Accumulator, prefix: Accumulator);
    // (undocumented)
    filterable: true;
    }

// @beta
export function startsWith(expr: string, prefix: string): StartsWith;

// @beta
export function startsWith(expr: string, prefix: Accumulator): StartsWith;

// @beta
export function startsWith(expr: Accumulator, prefix: string): StartsWith;

// @beta
export function startsWith(expr: Accumulator, prefix: Accumulator): StartsWith;

// @beta (undocumented)
export class StrConcat extends FirestoreFunction {
    constructor(first: Accumulator, rest: Accumulator[]);
    }

// @beta
export function strConcat(first: string, ...elements: Array<Accumulator | string>): StrConcat;

// @beta
export function strConcat(first: Accumulator, ...elements: Array<Accumulator | string>): StrConcat;

// @beta (undocumented)
export class StrContains extends FirestoreFunction implements FilterCondition {
    constructor(expr: Accumulator, substring: Accumulator);
    // (undocumented)
    filterable: true;
    }

// @beta
export function strContains(left: string, substring: string): StrContains;

// @beta
export function strContains(left: string, substring: Accumulator): StrContains;

// @beta
export function strContains(left: Accumulator, substring: string): StrContains;

// @beta
export function strContains(left: Accumulator, substring: Accumulator): StrContains;

// @beta (undocumented)
export class Subtract extends FirestoreFunction {
    constructor(left: Accumulator, right: Accumulator);
    }

// @beta
export function subtract(left: Accumulator, right: Accumulator): Subtract;

// @beta
export function subtract(left: Accumulator, right: any): Subtract;

// @beta
export function subtract(left: string, right: Accumulator): Subtract;

// @beta
export function subtract(left: string, right: any): Subtract;

// @beta (undocumented)
export class Sum extends FirestoreFunction implements Accumulator {
    constructor(value: Accumulator, distinct: boolean);
    // (undocumented)
    accumulator: true;
    }

// @beta (undocumented)
export class TimestampAdd extends FirestoreFunction {
    constructor(timestamp: Accumulator, unit: Accumulator, amount: Accumulator);
    }

// @beta
export function timestampAdd(timestamp: Accumulator, unit: Accumulator, amount: Accumulator): TimestampAdd;

// @beta
export function timestampAdd(timestamp: Accumulator, unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampAdd;

// @beta
export function timestampAdd(field: string, unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampAdd;

// @beta (undocumented)
export class TimestampSub extends FirestoreFunction {
    constructor(timestamp: Accumulator, unit: Accumulator, amount: Accumulator);
    }

// @beta
export function timestampSub(timestamp: Accumulator, unit: Accumulator, amount: Accumulator): TimestampSub;

// @beta
export function timestampSub(timestamp: Accumulator, unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampSub;

// @beta
export function timestampSub(field: string, unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day', amount: number): TimestampSub;

// @beta (undocumented)
export class TimestampToUnixMicros extends FirestoreFunction {
    constructor(input: Accumulator);
    }

// @beta
export function timestampToUnixMicros(expr: Accumulator): TimestampToUnixMicros;

// @beta
export function timestampToUnixMicros(field: string): TimestampToUnixMicros;

// @beta (undocumented)
export class TimestampToUnixMillis extends FirestoreFunction {
    constructor(input: Accumulator);
    }

// @beta
export function timestampToUnixMillis(expr: Accumulator): TimestampToUnixMillis;

// @beta
export function timestampToUnixMillis(field: string): TimestampToUnixMillis;

// @beta (undocumented)
export class TimestampToUnixSeconds extends FirestoreFunction {
    constructor(input: Accumulator);
    }

// @beta
export function timestampToUnixSeconds(expr: Accumulator): TimestampToUnixSeconds;

// @beta
export function timestampToUnixSeconds(field: string): TimestampToUnixSeconds;

// @beta (undocumented)
export class ToLower extends FirestoreFunction {
    constructor(expr: Accumulator);
    }

// @beta
export function toLower(expr: string): ToLower;

// @beta
export function toLower(expr: Accumulator): ToLower;

// @beta (undocumented)
export class ToUpper extends FirestoreFunction {
    constructor(expr: Accumulator);
    }

// @beta
export function toUpper(expr: string): ToUpper;

// @beta
export function toUpper(expr: Accumulator): ToUpper;

// @beta (undocumented)
export class Trim extends FirestoreFunction {
    constructor(expr: Accumulator);
    }

// @beta
export function trim(expr: string): Trim;

// @beta
export function trim(expr: Accumulator): Trim;

// @beta (undocumented)
export class UnixMicrosToTimestamp extends FirestoreFunction {
    constructor(input: Accumulator);
    }

// @beta
export function unixMicrosToTimestamp(expr: Accumulator): UnixMicrosToTimestamp;

// @beta
export function unixMicrosToTimestamp(field: string): UnixMicrosToTimestamp;

// @beta (undocumented)
export class UnixMillisToTimestamp extends FirestoreFunction {
    constructor(input: Accumulator);
    }

// @beta
export function unixMillisToTimestamp(expr: Accumulator): UnixMillisToTimestamp;

// @beta
export function unixMillisToTimestamp(field: string): UnixMillisToTimestamp;

// @beta (undocumented)
export class UnixSecondsToTimestamp extends FirestoreFunction {
    constructor(input: Accumulator);
    }

// @beta
export function unixSecondsToTimestamp(expr: Accumulator): UnixSecondsToTimestamp;

// @beta
export function unixSecondsToTimestamp(field: string): UnixSecondsToTimestamp;

// @beta (undocumented)
export class VectorLength extends FirestoreFunction {
    constructor(value: Accumulator);
    }

// @beta
export function vectorLength(expr: Accumulator): VectorLength;

// @beta
export function vectorLength(field: string): VectorLength;

// @beta (undocumented)
export class Where implements Stage {
    constructor(condition: FilterCondition);
    // (undocumented)
    name: string;
}

// @beta (undocumented)
export class Xor extends FirestoreFunction implements FilterCondition {
    constructor(conditions: (FilterCondition)[]);
    // (undocumented)
    filterable: true;
}

// @beta
export function xor(left: FilterCondition, ...right: (FilterCondition)[]): Xor;


// Warnings were encountered during analysis:
//
// /Users/markduckworth/projects/firebase-js-sdk/packages/firestore/dist/lite/pipelines.d.ts:10252:9 - (ae-incompatible-release-tags) The symbol "accumulators" is marked as @public, but its signature references "AccumulatorTarget" which is marked as @beta
// /Users/markduckworth/projects/firebase-js-sdk/packages/firestore/dist/lite/pipelines.d.ts:10253:9 - (ae-incompatible-release-tags) The symbol "groups" is marked as @public, but its signature references "Selectable" which is marked as @beta
// /Users/markduckworth/projects/firebase-js-sdk/packages/firestore/dist/lite/pipelines.d.ts:10282:9 - (ae-incompatible-release-tags) The symbol "orderings" is marked as @public, but its signature references "Ordering" which is marked as @beta

```
