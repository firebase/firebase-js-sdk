## API Report File for "@firebase/auth-types-exp"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { CompleteFn } from '@firebase/util';
import { ErrorFn } from '@firebase/util';
import { FirebaseError } from '@firebase/util';
import { NextFn } from '@firebase/util';
import { Observer } from '@firebase/util';
import { Unsubscribe } from '@firebase/util';

// @public
export interface ActionCodeInfo {
  data: {
    email?: string | null;
    multiFactorInfo?: MultiFactorInfo | null;
    previousEmail?: string | null;
  };
  operation: Operation;
}

// @public
export interface ActionCodeSettings {
  android?: {
    installApp?: boolean;
    minimumVersion?: string;
    packageName: string;
  };
  dynamicLinkDomain?: string;
  handleCodeInApp?: boolean;
  iOS?: {
    bundleId: string;
  };
  url: string;
}

// @public
export abstract class ActionCodeURL {
  readonly apiKey: string;
  readonly code: string;
  readonly continueUrl: string | null;
  readonly languageCode: string | null;
  readonly operation: Operation;
  static parseLink(link: string): ActionCodeURL | null;
  readonly tenantId: string | null;
}

// @public
export interface AdditionalUserInfo {
  readonly isNewUser: boolean;
  readonly profile: UserProfile | null;
  readonly providerId: ProviderId | null;
  readonly username?: string | null;
}

// @public
export interface ApplicationVerifier {
  readonly type: string;
  verify(): Promise<string>;
}

// @public
export interface Auth {
  readonly config: Config;
  readonly currentUser: User | null;
  languageCode: string | null;
  readonly name: string;
  onAuthStateChanged(
    nextOrObserver: NextOrObserver<User>,
    error?: ErrorFn,
    completed?: CompleteFn
  ): Unsubscribe;
  onIdTokenChanged(
    nextOrObserver: NextOrObserver<User>,
    error?: ErrorFn,
    completed?: CompleteFn
  ): Unsubscribe;
  setPersistence(persistence: Persistence): void;
  readonly settings: AuthSettings;
  signOut(): Promise<void>;
  tenantId: string | null;
  updateCurrentUser(user: User | null): Promise<void>;
  useDeviceLanguage(): void;
  useEmulator(url: string): void;
}

// @public
export abstract class AuthCredential {
  static fromJSON(json: object | string): AuthCredential | null;

  readonly providerId: string;

  readonly signInMethod: string;

  toJSON(): object;
}

// @public
export interface AuthError extends FirebaseError {
  readonly appName: string;
  readonly email?: string;
  readonly phoneNumber?: string;
  readonly tenantid?: string;
}

// @public
export interface AuthErrorMap {}

// @public
export interface AuthProvider {
  readonly providerId: string;
}

// @public
export interface AuthSettings {
  appVerificationDisabledForTesting: boolean;
}

// @public
export interface Config {
  apiHost: string;
  apiKey: string;
  apiScheme: string;
  authDomain?: string;
  sdkClientVersion: string;
  tokenApiHost: string;
}

// @public
export interface ConfirmationResult {
  confirm(verificationCode: string): Promise<UserCredential>;
  readonly verificationId: string;
}

// @public
export abstract class EmailAuthProvider implements AuthProvider {
  static credential(email: string, password: string): AuthCredential;
  static credentialWithLink(
    auth: Auth,
    email: string,
    emailLink: string
  ): AuthCredential;
  static readonly EMAIL_LINK_SIGN_IN_METHOD: SignInMethod;
  static readonly EMAIL_PASSWORD_SIGN_IN_METHOD: SignInMethod;
  static readonly PROVIDER_ID: ProviderId;
  readonly providerId: ProviderId;
}

// @public
export interface IdTokenResult {
  authTime: string;
  claims: ParsedToken;
  expirationTime: string;
  issuedAtTime: string;
  signInProvider: string | null;
  signInSecondFactor: string | null;
  token: string;
}

// @public
export interface MultiFactorAssertion {
  readonly factorId: string;
}

// @public
export interface MultiFactorError extends AuthError {
  readonly credential: AuthCredential;
  readonly operationType: OperationType;
}

// @public
export interface MultiFactorInfo {
  readonly displayName?: string | null;
  readonly enrollmentTime: string;
  readonly factorId: ProviderId;
  readonly uid: string;
}

// @public
export abstract class MultiFactorResolver {
  hints: MultiFactorInfo[];
  resolveSignIn(assertion: MultiFactorAssertion): Promise<UserCredential>;
  session: MultiFactorSession;
}

// @public
export interface MultiFactorSession {}

// @public
export interface MultiFactorUser {
  enroll(
    assertion: MultiFactorAssertion,
    displayName?: string | null
  ): Promise<void>;
  readonly enrolledFactors: MultiFactorInfo[];
  getSession(): Promise<MultiFactorSession>;
  unenroll(option: MultiFactorInfo | string): Promise<void>;
}

// @public
export type NextOrObserver<T> = NextFn<T | null> | Observer<T | null>;

// @public
export abstract class OAuthCredential extends AuthCredential {
  readonly accessToken?: string;

  static fromJSON(json: object | string): OAuthCredential | null;

  readonly idToken?: string;

  readonly secret?: string;
}

// @public
export const enum Operation {
  EMAIL_SIGNIN = 'EMAIL_SIGNIN',
  PASSWORD_RESET = 'PASSWORD_RESET',
  RECOVER_EMAIL = 'RECOVER_EMAIL',
  REVERT_SECOND_FACTOR_ADDITION = 'REVERT_SECOND_FACTOR_ADDITION',
  VERIFY_AND_CHANGE_EMAIL = 'VERIFY_AND_CHANGE_EMAIL',
  VERIFY_EMAIL = 'VERIFY_EMAIL'
}

// @public
export const enum OperationType {
  LINK = 'link',
  REAUTHENTICATE = 'reauthenticate',
  SIGN_IN = 'signIn'
}

// @public
export interface ParsedToken {
  [key: string]: string | object | undefined;
  'auth_time'?: string;
  'exp'?: string;
  'firebase'?: {
    'sign_in_provider'?: string;
    'sign_in_second_factor'?: string;
  };
  'iat'?: string;
  'sub'?: string;
}

// @public
export interface Persistence {
  readonly type: 'SESSION' | 'LOCAL' | 'NONE';
}

// @public
export abstract class PhoneAuthCredential extends AuthCredential {
  // (undocumented)
  static fromJSON(json: object | string): PhoneAuthCredential | null;
  // (undocumented)
  toJSON(): object;
}

// @public
export class PhoneAuthProvider implements AuthProvider {
  constructor(auth?: Auth | null);
  static credential(
    verificationId: string,
    verificationCode: string
  ): AuthCredential;
  static readonly PHONE_SIGN_IN_METHOD: SignInMethod;
  static readonly PROVIDER_ID: ProviderId;
  readonly providerId: ProviderId;
  verifyPhoneNumber(
    phoneInfoOptions: PhoneInfoOptions | string,
    applicationVerifier: ApplicationVerifier
  ): Promise<string>;
}

// @public
export type PhoneInfoOptions =
  | PhoneSingleFactorInfoOptions
  | PhoneMultiFactorEnrollInfoOptions
  | PhoneMultiFactorSignInInfoOptions;

// @public
export interface PhoneMultiFactorAssertion extends MultiFactorAssertion {}

// @public
export interface PhoneMultiFactorEnrollInfoOptions {
  phoneNumber: string;
  session: MultiFactorSession;
}

// @public
export abstract class PhoneMultiFactorGenerator {
  static assertion(
    phoneAuthCredential: PhoneAuthCredential
  ): PhoneMultiFactorAssertion;
  static FACTOR_ID: ProviderId;
}

// @public
export interface PhoneMultiFactorSignInInfoOptions {
  multiFactorHint?: MultiFactorInfo;
  multiFactorUid?: string;
  session: MultiFactorSession;
}

// @public
export interface PhoneSingleFactorInfoOptions {
  phoneNumber: string;
}

// @public
export interface PopupRedirectResolver {}

// @public
export const enum ProviderId {
  // (undocumented)
  ANONYMOUS = 'anonymous',
  // (undocumented)
  CUSTOM = 'custom',
  // (undocumented)
  FACEBOOK = 'facebook.com',
  // (undocumented)
  FIREBASE = 'firebase',
  // (undocumented)
  GITHUB = 'github.com',
  // (undocumented)
  GOOGLE = 'google.com',
  // (undocumented)
  PASSWORD = 'password',
  // (undocumented)
  PHONE = 'phone',
  // (undocumented)
  TWITTER = 'twitter.com'
}

// @public
export interface ReactNativeAsyncStorage {
  getItem(key: string): Promise<string | null>;
  removeItem(key: string): Promise<void>;
  setItem(key: string, value: string): Promise<void>;
}

// @public
export abstract class RecaptchaVerifier implements ApplicationVerifier {
  constructor(
    container: any | string,
    parameters?: Object | null,
    auth?: Auth | null
  );
  clear(): void;
  render(): Promise<number>;
  readonly type: string;
  verify(): Promise<string>;
}

// @public
export const enum SignInMethod {
  // (undocumented)
  ANONYMOUS = 'anonymous',
  // (undocumented)
  EMAIL_LINK = 'emailLink',
  // (undocumented)
  EMAIL_PASSWORD = 'password',
  // (undocumented)
  FACEBOOK = 'facebook.com',
  // (undocumented)
  GITHUB = 'github.com',
  // (undocumented)
  GOOGLE = 'google.com',
  // (undocumented)
  PHONE = 'phone',
  // (undocumented)
  TWITTER = 'twitter.com'
}

// @public
export interface User extends UserInfo {
  delete(): Promise<void>;
  readonly emailVerified: boolean;
  getIdToken(forceRefresh?: boolean): Promise<string>;
  getIdTokenResult(forceRefresh?: boolean): Promise<IdTokenResult>;
  readonly isAnonymous: boolean;
  readonly metadata: UserMetadata;
  readonly providerData: UserInfo[];
  readonly refreshToken: string;
  reload(): Promise<void>;
  readonly tenantId: string | null;
  toJSON(): object;
}

// @public
export interface UserCredential {
  operationType: OperationType;
  providerId: ProviderId | null;
  user: User;
}

// @public
export interface UserInfo {
  readonly displayName: string | null;
  readonly email: string | null;
  readonly phoneNumber: string | null;
  readonly photoURL: string | null;
  readonly providerId: string;
  readonly uid: string;
}

// @public
export interface UserMetadata {
  readonly creationTime?: string;
  readonly lastSignInTime?: string;
}

// @public
export type UserProfile = Record<string, unknown>;


// (No @packageDocumentation comment for this package)

```
